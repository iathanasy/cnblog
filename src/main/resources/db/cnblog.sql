/*
Navicat MySQL Data Transfer

Source Server         : 127.0.0.1
Source Server Version : 50715
Source Host           : 127.0.0.1:3306
Source Database       : cnblog

Target Server Type    : MYSQL
Target Server Version : 50715
File Encoding         : 65001

Date: 2020-11-01 20:34:41
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `biz_article`
-- ----------------------------
DROP TABLE IF EXISTS `biz_article`;
CREATE TABLE `biz_article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `category_id` bigint(20) DEFAULT NULL COMMENT '文章分类Id',
  `title` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '文章标题',
  `summary` varchar(255) DEFAULT NULL COMMENT '文章摘要（简介）',
  `cover_image` varchar(255) DEFAULT NULL COMMENT '文章封面图片',
  `md` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否markdown编辑器 1是 0否',
  `content` mediumtext CHARACTER SET utf8mb4 COMMENT '文章内容',
  `content_md` mediumtext CHARACTER SET utf8mb4 COMMENT 'markdown版的文章内容',
  `status` tinyint(1) DEFAULT '1' COMMENT '状态 0草稿 1发布',
  `top` tinyint(1) DEFAULT '0' COMMENT '是否置顶 0否 1是',
  `recommended` tinyint(1) DEFAULT '0' COMMENT '是否推荐 0否 1是',
  `original` tinyint(1) DEFAULT '1' COMMENT '是否原创',
  `comment` tinyint(1) DEFAULT '1' COMMENT '是否开启评论 0否 1是',
  `password` varchar(20) DEFAULT NULL COMMENT '访问密码 为空表示没有密码',
  `pv` bigint(25) DEFAULT '0' COMMENT '浏览量',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 COMMENT='文章表';

-- ----------------------------
-- Records of biz_article
-- ----------------------------
INSERT INTO `biz_article` VALUES ('1', '1', '2', 'Markdown 写作', '写作', '/profile/upload/2020/07/01/00.jpg', '1', '<h1 id=\"-markdown-mdeditor\">欢迎使用 Markdown在线编辑器 MdEditor</h1>\n<p><strong>Markdown是一种轻量级的「标记语言」</strong></p>\n<p><img src=\"/profile/upload/2020/07/01/1593614174191.jpg\" alt=\"2020/07/01/1593614174191.jpg\" width=\"89px\" height=\"79px\"> </p>\n<p><img src=\"/profile/upload/2020/07/01/1593614211750.png\" alt=\"2020/07/01/1593614211750.png\" width=\"806px\" height=\"389px\"> </p>\n<p><img src=\"/profile/upload/2020/07/01/1593614262455.jpg\" alt=\"2020/07/01/1593614262455.jpg\" width=\"1680px\" height=\"1050px\"> </p>\n<p><img src=\"/profile/upload/2020/07/01/1593614301833.jpg\" alt=\"2020/07/01/1593614301833.jpg\" width=\"200px\" height=\"200px\"> </p>\n<p><img src=\"/profile/upload/2020/07/01/1593614324400.jpg\" alt=\"2020/07/01/1593614324400.jpg\" width=\"200px\" height=\"200px\"> </p>\n<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>\n<h2 id=\"mdeditor-markdown-\">MdEditor是一个在线编辑Markdown文档的编辑器</h2>\n<p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p>\n<blockquote>\n<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>\n</blockquote>\n<p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href=\"https://github.com/pandao/editor.md\" title=\"Editor.md\">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p>\n<p><img src=\"https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png\" alt=\"Pandao editor.md\" width=\"\" height=\"\"> title=\"Pandao editor.md\"&gt;</p>\n<h2 id=\"mdeditor-\">MdEditor的功能列表演示</h2>\n<h1 id=\"-h1\">标题H1</h1>\n<h2 id=\"-h2\">标题H2</h2>\n<h3 id=\"-h3\">标题H3</h3>\n<h4 id=\"-h4\">标题H4</h4>\n<h5 id=\"-h5\">标题H5</h5>\n<h6 id=\"-h5\">标题H5</h6>\n<h3 id=\"-\">字符效果和横线等</h3>\n<hr>\n<p><del>删除线</del> &lt;s&gt;删除线（开启识别HTML标签时）&lt;/s&gt;</p>\n<p><em>斜体字</em>      <em>斜体字</em></p>\n<p><strong>粗体</strong>  <strong>粗体</strong></p>\n<p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>\n<p>上标：X&lt;sub&gt;2&lt;/sub&gt;，下标：O&lt;sup&gt;2&lt;/sup&gt;</p>\n<p><strong>缩写(同HTML的abbr标签)</strong></p>\n<blockquote>\n<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>\n</blockquote>\n<p>The &lt;abbr title=\"Hyper Text Markup Language\"&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=\"World Wide Web Consortium\"&gt;W3C&lt;/abbr&gt;.</p>\n<h3 id=\"-blockquotes\">引用 Blockquotes</h3>\n<blockquote>\n<p>引用文本 Blockquotes</p>\n</blockquote>\n<p>引用的行内混合 Blockquotes</p>\n<blockquote>\n<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href=\"https://www.mdeditor.com/\">普通链接</a>。</p>\n</blockquote>\n<h3 id=\"-links\">锚点与链接 Links</h3>\n<p><a href=\"https://www.mdeditor.com/\">普通链接</a><br><a href=\"https://www.mdeditor.com/\" title=\"普通链接带标题\">普通链接带标题</a><br>直接链接：<a href=\"https://www.mdeditor.com\">https://www.mdeditor.com</a><br><a href=\"https://www.mdeditor.com/\">锚点链接</a></p>\n<p><a href=\"mailto:test.test@gmail.com\">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com</p>\n<blockquote>\n<p>@pandao</p>\n</blockquote>\n<h3 id=\"-codes\">多语言代码高亮 Codes</h3>\n<h4 id=\"-inline-code\">行内代码 Inline code</h4>\n<p>执行命令：<code>npm install marked</code></p>\n<h4 id=\"-\">缩进风格</h4>\n<p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-none\" style=\"white-space: pre-wrap;\"><code class=\"language-none\">&lt;?php\n    echo \"Hello world!\";\n?&gt;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div><p>预格式化文本：</p>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-none\" style=\"white-space: pre-wrap;\"><code class=\"language-none\">| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div><h4 id=\"js-\">JS代码</h4>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-javascript\" style=\"white-space: pre-wrap;\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h4 id=\"html-html-codes\">HTML 代码 HTML codes</h4>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-html\" style=\"white-space: pre-wrap;\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mate</span> <span class=\"token attr-name\">charest</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>utf-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>keywords<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Editor.md, Markdown, Editor<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">&gt;</span></span>Hello world!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/css<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span><span class=\"token style\"><span class=\"token language-css\">\n            <span class=\"token selector\">body</span><span class=\"token punctuation\">{</span><span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span>14px<span class=\"token punctuation\">;</span><span class=\"token property\">color</span><span class=\"token punctuation\">:</span>#444<span class=\"token punctuation\">;</span><span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Microsoft Yahei\"</span><span class=\"token punctuation\">,</span> Tahoma<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hiragino Sans GB\"</span><span class=\"token punctuation\">,</span> Arial<span class=\"token punctuation\">;</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span>#fff<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n            <span class=\"token selector\">ul</span><span class=\"token punctuation\">{</span><span class=\"token property\">list-style</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n            <span class=\"token selector\">img</span><span class=\"token punctuation\">{</span><span class=\"token property\">border</span><span class=\"token punctuation\">:</span>none<span class=\"token punctuation\">;</span><span class=\"token property\">vertical-align</span><span class=\"token punctuation\">:</span> middle<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n        </span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text-xxl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>Hello world!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text-green<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">&gt;</span></span>Plain text<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">&gt;</span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 72px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 96px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h3 id=\"-images\">图片 Images</h3>\n<p>图片加链接 (Image + Link)：</p>\n<p><a href=\"https://www.mdeditor.com/images/logos/markdown.png\" title=\"markdown\"><img src=\"https://www.mdeditor.com/images/logos/markdown.png\" alt=\"\" width=\"\" height=\"\"></a></p>\n<blockquote>\n<p>Follow your heart.</p>\n</blockquote>\n<hr>\n<h3 id=\"-lists\">列表 Lists</h3>\n<h4 id=\"-unordered-lists-\">无序列表（减号）Unordered Lists (-)</h4>\n<ul>\n<li>列表一</li>\n<li>列表二</li>\n<li>列表三</li>\n</ul>\n<h4 id=\"-unordered-lists-\">无序列表（星号）Unordered Lists (*)</h4>\n<ul>\n<li>列表一</li>\n<li>列表二</li>\n<li>列表三</li>\n</ul>\n<h4 id=\"-unordered-lists-\">无序列表（加号和嵌套）Unordered Lists (+)</h4>\n<ul>\n<li>列表一</li>\n<li>列表二<ul>\n<li>列表二-1</li>\n<li>列表二-2</li>\n<li>列表二-3</li>\n</ul>\n</li>\n<li>列表三<ul>\n<li>列表一</li>\n<li>列表二</li>\n<li>列表三</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-ordered-lists-\">有序列表 Ordered Lists (-)</h4>\n<ol>\n<li>第一行</li>\n<li>第二行</li>\n<li>第三行</li>\n</ol>\n<h4 id=\"gfm-task-list\">GFM task list</h4>\n<ul>\n<li>[x] GFM task list 1</li>\n<li>[x] GFM task list 2</li>\n<li>[ ] GFM task list 3<ul>\n<li>[ ] GFM task list 3-1</li>\n<li>[ ] GFM task list 3-2</li>\n<li>[ ] GFM task list 3-3</li>\n</ul>\n</li>\n<li>[ ] GFM task list 4<ul>\n<li>[ ] GFM task list 4-1</li>\n<li>[ ] GFM task list 4-2</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"-tables\">绘制表格 Tables</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>First Header</th>\n<th>Second Header</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content Cell</td>\n<td>Content Cell</td>\n</tr>\n<tr>\n<td>Content Cell</td>\n<td>Content Cell</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>First Header</th>\n<th>Second Header</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content Cell</td>\n<td>Content Cell</td>\n</tr>\n<tr>\n<td>Content Cell</td>\n<td>Content Cell</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Function name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>help()</code></td>\n<td>Display the help window.</td>\n</tr>\n<tr>\n<td><code>destroy()</code></td>\n<td><strong>Destroy your computer!</strong></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Left-Aligned</th>\n<th style=\"text-align:center\">Center Aligned</th>\n<th style=\"text-align:right\">Right Aligned</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">col 3 is</td>\n<td style=\"text-align:center\">some wordy text</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Item</th>\n<th style=\"text-align:right\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Computer</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>Phone</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>Pipe</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4 id=\"-html-entities-codes\">特殊符号 HTML Entities Codes</h4>\n<p>© &amp;  ¨ ™ ¡ £<br>&amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « ·</p>\n<p>X² Y³ ¾ ¼  ×  ÷   »</p>\n<p>18ºC  \"  \'</p>\n<p>[========]</p>\n<h3 id=\"emoji-smiley-\">Emoji表情 :smiley:</h3>\n<blockquote>\n<p>Blockquotes :star:</p>\n</blockquote>\n<h4 id=\"gfm-task-lists-emoji-fontawesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x-\">GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4>\n<ul>\n<li>[x] :smiley: @mentions, :smiley: #refs, <a href=\"\">links</a>, <strong>formatting</strong>, and &lt;del&gt;tags&lt;/del&gt; supported :editormd-logo:;</li>\n<li>[x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>\n<li>[x] [ ] :smiley: this is a complete item :smiley:;</li>\n<li>[ ] []this is an incomplete item <a href=\"#\">test link</a> :fa-star: @pandao;</li>\n<li>[ ] [ ]this is an incomplete item :fa-star: :fa-gear:;<ul>\n<li>[ ] :smiley: this is an incomplete item <a href=\"#\">test link</a> :fa-star: :fa-gear:;</li>\n<li>[ ] :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href=\"#\">test link</a>;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-escape\">反斜杠 Escape</h4>\n<p>*literal asterisks*</p>\n<p>[========]</p>\n<h3 id=\"end\">End</h3>\n', '# 欢迎使用 Markdown在线编辑器 MdEditor\n\n**Markdown是一种轻量级的「标记语言」**\n\n\n![2020/07/01/1593614174191.jpg =89*79](/profile/upload/2020/07/01/1593614174191.jpg) \n\n\n![2020/07/01/1593614211750.png =806*389](/profile/upload/2020/07/01/1593614211750.png) \n\n![2020/07/01/1593614262455.jpg =1680*1050](/profile/upload/2020/07/01/1593614262455.jpg) \n\n![2020/07/01/1593614301833.jpg =200*200](/profile/upload/2020/07/01/1593614301833.jpg) \n\n![2020/07/01/1593614324400.jpg =200*200](/profile/upload/2020/07/01/1593614324400.jpg) \n\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”\n\n\n## MdEditor是一个在线编辑Markdown文档的编辑器\n\n*MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。*\n\n> Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如~~Pandoc~~，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。\n\nMdEditor源于Pandao的JavaScript开源项目，开源地址[Editor.md](https://github.com/pandao/editor.md \"Editor.md\")，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。\n\n\n![Pandao editor.md](https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png \"Pandao editor.md\")\n\n\n\n## MdEditor的功能列表演示\n\n# 标题H1\n\n## 标题H2\n\n### 标题H3\n\n#### 标题H4\n\n##### 标题H5\n\n###### 标题H5\n\n### 字符效果和横线等\n----\n\n~~删除线~~ <s>删除线（开启识别HTML标签时）</s>\n\n*斜体字*      _斜体字_\n\n**粗体**  __粗体__\n\n***粗斜体*** ___粗斜体___\n\n上标：X<sub>2</sub>，下标：O<sup>2</sup>\n\n**缩写(同HTML的abbr标签)**\n> 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启\n\nThe <abbr title=\"Hyper Text Markup Language\">HTML</abbr> specification is maintained by the <abbr title=\"World Wide Web Consortium\">W3C</abbr>.\n### 引用 Blockquotes\n\n> 引用文本 Blockquotes\n\n引用的行内混合 Blockquotes\n\n> 引用：如果想要插入空白换行`即<br />标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](https://www.mdeditor.com/)。\n\n### 锚点与链接 Links\n[普通链接](https://www.mdeditor.com/)\n[普通链接带标题](https://www.mdeditor.com/ \"普通链接带标题\")\n直接链接：<https://www.mdeditor.com>\n[锚点链接][anchor-id]\n[anchor-id]: https://www.mdeditor.com/\n[mailto:test.test@gmail.com](mailto:test.test@gmail.com)\nGFM a-tail link @pandao\n邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com\n> @pandao\n\n### 多语言代码高亮 Codes\n\n#### 行内代码 Inline code\n\n\n执行命令：`npm install marked`\n\n#### 缩进风格\n\n即缩进四个空格，也做为实现类似 `<pre>` 预格式化文本 ( Preformatted Text ) 的功能。\n\n    <?php\n        echo \"Hello world!\";\n    ?>\n预格式化文本：\n\n    | First Header  | Second Header |\n    | ------------- | ------------- |\n    | Content Cell  | Content Cell  |\n    | Content Cell  | Content Cell  |\n\n#### JS代码\n```javascript\nfunction test() {\n	console.log(\"Hello world!\");\n}\n```\n\n#### HTML 代码 HTML codes\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <mate charest=\"utf-8\" />\n        <meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" />\n        <title>Hello world!</title>\n        <style type=\"text/css\">\n            body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;}\n            ul{list-style: none;}\n            img{border:none;vertical-align: middle;}\n        </style>\n    </head>\n    <body>\n        <h1 class=\"text-xxl\">Hello world!</h1>\n        <p class=\"text-green\">Plain text</p>\n    </body>\n</html>\n```\n### 图片 Images\n\n图片加链接 (Image + Link)：\n\n\n[![](https://www.mdeditor.com/images/logos/markdown.png)](https://www.mdeditor.com/images/logos/markdown.png \"markdown\")\n\n> Follow your heart.\n\n----\n### 列表 Lists\n\n#### 无序列表（减号）Unordered Lists (-)\n\n- 列表一\n- 列表二\n- 列表三\n\n#### 无序列表（星号）Unordered Lists (*)\n\n* 列表一\n* 列表二\n* 列表三\n\n#### 无序列表（加号和嵌套）Unordered Lists (+)\n+ 列表一\n+ 列表二\n    + 列表二-1\n    + 列表二-2\n    + 列表二-3\n+ 列表三\n    * 列表一\n    * 列表二\n    * 列表三\n\n#### 有序列表 Ordered Lists (-)\n\n1. 第一行\n2. 第二行\n3. 第三行\n\n#### GFM task list\n\n- [x] GFM task list 1\n- [x] GFM task list 2\n- [ ] GFM task list 3\n    - [ ] GFM task list 3-1\n    - [ ] GFM task list 3-2\n    - [ ] GFM task list 3-3\n- [ ] GFM task list 4\n    - [ ] GFM task list 4-1\n    - [ ] GFM task list 4-2\n\n----\n\n### 绘制表格 Tables\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机      | $1600   |   5     |\n| 手机        |   $12   |   12   |\n| 管线        |    $1    |  234  |\n\nFirst Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n| Function name | Description                    |\n| ------------- | ------------------------------ |\n| `help()`      | Display the help window.       |\n| `destroy()`   | **Destroy your computer!**     |\n\n| Left-Aligned  | Center Aligned  | Right Aligned |\n| :------------ |:---------------:| -----:|\n| col 3 is      | some wordy text | $1600 |\n| col 2 is      | centered        |   $12 |\n| zebra stripes | are neat        |    $1 |\n\n| Item      | Value |\n| --------- | -----:|\n| Computer  | $1600 |\n| Phone     |   $12 |\n| Pipe      |    $1 |\n\n----\n\n#### 特殊符号 HTML Entities Codes\n\n&copy; &  &uml; &trade; &iexcl; &pound;\n&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;\n\nX&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;\n\n18&ordm;C  &quot;  &apos;\n\n[========]\n\n### Emoji表情 :smiley:\n\n> Blockquotes :star:\n\n#### GFM task lists & Emoji & fontAwesome icon emoji & editormd logo emoji :editormd-logo-5x:\n\n- [x] :smiley: @mentions, :smiley: #refs, [links](), **formatting**, and <del>tags</del> supported :editormd-logo:;\n- [x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;\n- [x] [ ] :smiley: this is a complete item :smiley:;\n- [ ] []this is an incomplete item [test link](#) :fa-star: @pandao;\n- [ ] [ ]this is an incomplete item :fa-star: :fa-gear:;\n    - [ ] :smiley: this is an incomplete item [test link](#) :fa-star: :fa-gear:;\n    - [ ] :smiley: this is  :fa-star: :fa-gear: an incomplete item [test link](#);\n\n#### 反斜杠 Escape\n\n\\*literal asterisks\\*\n\n[========]\n\n### End', '1', '1', '1', '1', '1', '', '19', 'admin', '2020-02-18 15:14:10', 'admin', '2020-07-01 22:39:08');
INSERT INTO `biz_article` VALUES ('4', '1', '4', '哈哈1', '摘要', '', '1', '<h1 id=\"h1-u54C8u54C8\"><a name=\"哈哈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>哈哈</h1><h2 id=\"h2-u8FD9u79CD\"><a name=\"这种\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这种</h2><blockquote>\n<p>zs请求</p>\n</blockquote>\n', '# 哈哈\n\n## 这种\n> zs请求\n', '1', '1', '0', '0', '1', '123', '4', 'admin', '2020-02-22 17:56:12', 'admin', '2020-04-18 00:25:58');
INSERT INTO `biz_article` VALUES ('5', '1', '3', '设计模式也可以这么简单', '设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 *Gang of Four* (*GoF*) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。', '', '1', '<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p>\n<p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>\n<ol>\n<li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol>\n<p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p>\n<h2 id=\"h2-u521Bu5EFAu578Bu6A21u5F0F\"><a name=\"创建型模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>\n<h3 id=\"h3-u7B80u5355u5DE5u5382u6A21u5F0F\"><a name=\"简单工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p>\n<pre><code class=\"lang-java\">public class FoodFactory {\n\n    public static Food makeFood(String name) {\n        if (name.equals(\"noodle\")) {\n            Food noodle = new LanZhouNoodle();\n            noodle.addSpicy(\"more\");\n            return noodle;\n        } else if (name.equals(\"chicken\")) {\n            Food chicken = new HuangMenChicken();\n            chicken.addCondiment(\"potato\");\n            return chicken;\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre>\n<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>\n<p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>\n<blockquote>\n<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>\n</blockquote>\n<h3 id=\"h3-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>\n<pre><code class=\"lang-java\">public interface FoodFactory {\n    Food makeFood(String name);\n}\npublic class ChineseFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new ChineseFoodA();\n        } else if (name.equals(\"B\")) {\n            return new ChineseFoodB();\n        } else {\n            return null;\n        }\n    }\n}\npublic class AmericanFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new AmericanFoodA();\n        } else if (name.equals(\"B\")) {\n            return new AmericanFoodB();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre>\n<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>\n<p>客户端调用：</p>\n<pre><code class=\"lang-java\">public class APP {\n    public static void main(String[] args) {\n        // 先选择一个具体的工厂\n        FoodFactory factory = new ChineseFoodFactory();\n        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象\n        Food food = factory.makeFood(\"A\");\n    }\n}\n</code></pre>\n<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>\n<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>\n<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>\n<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/factory-1.png\" alt=\"factory-1\">\n<h3 id=\"h3-u62BDu8C61u5DE5u5382u6A21u5F0F\"><a name=\"抽象工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p>\n<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>\n<p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png\" alt=\"factory-1\">\n<p>这个时候的客户端调用是这样的：</p>\n<pre><code class=\"lang-java\">// 得到 Intel 的 CPU\nCPUFactory cpuFactory = new IntelCPUFactory();\nCPU cpu = intelCPUFactory.makeCPU();\n\n// 得到 AMD 的主板\nMainBoardFactory mainBoardFactory = new AmdMainBoardFactory();\nMainBoard mainBoard = mainBoardFactory.make();\n\n// 组装 CPU 和主板\nComputer computer = new Computer(cpu, mainBoard);\n</code></pre>\n<p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>\n<p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>\n<p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png\" alt=\"abstract-factory-2\">\n<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png\" alt=\"abstract-factory-3\">\n<p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 第一步就要选定一个“大厂”\n    ComputerFactory cf = new AmdFactory();\n    // 从这个大厂造 CPU\n    CPU cpu = cf.makeCPU();\n    // 从这个大厂造主板\n    MainBoard board = cf.makeMainBoard();\n      // 从这个大厂造硬盘\n      HardDisk hardDisk = cf.makeHardDisk();\n\n    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起\n    Computer result = new Computer(cpu, board, hardDisk);\n}\n</code></pre>\n<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>\n<h3 id=\"h3-u5355u4F8Bu6A21u5F0F\"><a name=\"单例模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单例模式</h3><p>单例模式用得最多，错得最多。</p>\n<p>饿汉模式最简单：</p>\n<pre><code class=\"lang-java\">public class Singleton {\n    // 首先，将 new Singleton() 堵死\n    private Singleton() {};\n    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建\n    private static Singleton instance = new Singleton();\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，\n    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了\n    public static Date getDate(String mode) {return new Date();}\n}\n</code></pre>\n<blockquote>\n<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>\n</blockquote>\n<p>饱汉模式最容易出错：</p>\n<pre><code class=\"lang-java\">public class Singleton {\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() {}\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            // 加锁\n            synchronized (Singleton.class) {\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n</code></pre>\n<blockquote>\n<p>双重检查，指的是两次检查 instance 是否为 null。</p>\n<p>volatile 在这里是需要的，希望能引起读者的关注。</p>\n<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>\n</blockquote>\n<p>嵌套类最经典，以后大家就用它吧：</p>\n<pre><code class=\"lang-java\">public class Singleton3 {\n\n    private Singleton3() {}\n    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性\n    private static class Holder {\n        private static Singleton3 instance = new Singleton3();\n    }\n    public static Singleton3 getInstance() {\n        return Holder.instance;\n    }\n}\n</code></pre>\n<blockquote>\n<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>\n</blockquote>\n<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>\n<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>\n<h3 id=\"h3-u5EFAu9020u8005u6A21u5F0F\"><a name=\"建造者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>\n<pre><code class=\"lang-java\">Food food = new FoodBuilder().a().b().c().build();\nFood food = Food.builder().a().b().c().build();\n</code></pre>\n<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>\n<p>来一个中规中矩的建造者模式：</p>\n<pre><code class=\"lang-java\">class User {\n    // 下面是“一堆”的属性\n    private String name;\n    private String password;\n    private String nickName;\n    private int age;\n\n    // 构造方法私有化，不然客户端就会直接调用构造方法了\n    private User(String name, String password, String nickName, int age) {\n        this.name = name;\n        this.password = password;\n        this.nickName = nickName;\n        this.age = age;\n    }\n    // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，\n    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好\n    public static UserBuilder builder() {\n        return new UserBuilder();\n    }\n\n    public static class UserBuilder {\n        // 下面是和 User 一模一样的一堆属性\n        private String  name;\n        private String password;\n        private String nickName;\n        private int age;\n\n        private UserBuilder() {\n        }\n\n        // 链式调用设置各个属性值，返回 this，即 UserBuilder\n        public UserBuilder name(String name) {\n            this.name = name;\n            return this;\n        }\n\n        public UserBuilder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n        public UserBuilder nickName(String nickName) {\n            this.nickName = nickName;\n            return this;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。\n        // 当然，可以在 “复制” 之前做点检验\n        public User build() {\n            if (name == null || password == null) {\n                throw new RuntimeException(\"用户名和密码必填\");\n            }\n            if (age &lt;= 0 || age &gt;= 150) {\n                throw new RuntimeException(\"年龄不合法\");\n            }\n            // 还可以做赋予”默认值“的功能\n              if (nickName == null) {\n                nickName = name;\n            }\n            return new User(name, password, nickName, age);\n        }\n    }\n}\n</code></pre>\n<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p>\n<p>看看客户端的调用：</p>\n<pre><code class=\"lang-java\">public class APP {\n    public static void main(String[] args) {\n        User d = User.builder()\n                .name(\"foo\")\n                .password(\"pAss12345\")\n                .age(25)\n                .build();\n    }\n}\n</code></pre>\n<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>\n<blockquote>\n<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>\n</blockquote>\n<pre><code class=\"lang-java\">@Builder\nclass User {\n    private String  name;\n    private String password;\n    private String nickName;\n    private int age;\n}\n</code></pre>\n<blockquote>\n<p>怎么样，省下来的时间是不是又可以干点别的了。</p>\n</blockquote>\n<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>\n<pre><code class=\"lang-java\">User user = new User().setName(\"\").setPassword(\"\").setAge(20);\n</code></pre>\n<blockquote>\n<p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p>\n</blockquote>\n<h3 id=\"h3-u539Fu578Bu6A21u5F0F\"><a name=\"原型模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p>\n<p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p>\n<p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p>\n<pre><code class=\"lang-java\">protected native Object clone() throws CloneNotSupportedException;\n</code></pre>\n<blockquote>\n<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>\n</blockquote>\n<p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>\n<h3 id=\"h3-u521Bu5EFAu578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"创建型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p>\n<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>\n<h2 id=\"h2-u7ED3u6784u578Bu6A21u5F0F\"><a name=\"结构型模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>\n<h3 id=\"h3-u4EE3u7406u6A21u5F0F\"><a name=\"代理模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>\n<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>\n<blockquote>\n<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p>\n</blockquote>\n<pre><code class=\"lang-java\">public interface FoodService {\n    Food makeChicken();\n    Food makeNoodle();\n}\n\npublic class FoodServiceImpl implements FoodService {\n    public Food makeChicken() {\n          Food f = new Chicken()\n        f.setChicken(\"1kg\");\n          f.setSpicy(\"1g\");\n          f.setSalt(\"3g\");\n        return f;\n    }\n    public Food makeNoodle() {\n        Food f = new Noodle();\n        f.setNoodle(\"500g\");\n        f.setSalt(\"5g\");\n        return f;\n    }\n}\n\n// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService\npublic class FoodServiceProxy implements FoodService {\n\n    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入\n    private FoodService foodService = new FoodServiceImpl();\n\n    public Food makeChicken() {\n        System.out.println(\"我们马上要开始制作鸡肉了\");\n\n        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，\n        // 代理只是在核心代码前后做些“无足轻重”的事情\n        Food food = foodService.makeChicken();\n\n        System.out.println(\"鸡肉制作完成啦，加点胡椒粉\"); // 增强\n          food.addCondiment(\"pepper\");\n\n        return food;\n    }\n    public Food makeNoodle() {\n        System.out.println(\"准备制作拉面~\");\n        Food food = foodService.makeNoodle();\n        System.out.println(\"制作完成啦\")\n        return food;\n    }\n}\n</code></pre>\n<p>客户端调用，注意，我们要用代理来实例化接口：</p>\n<pre><code class=\"lang-java\">// 这里用代理类来实例化\nFoodService foodService = new FoodServiceProxy();\nfoodService.makeChicken();\n</code></pre>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/proxy-1.png\" alt=\"proxy\">\n<p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 <a href=\"https://github.com/Before\" title=\"@Before\" class=\"at-link\">@Before</a>、<a href=\"https://github.com/After\" title=\"@After\" class=\"at-link\">@After</a>、<a href=\"https://github.com/Around\" title=\"@Around\" class=\"at-link\">@Around</a> 中的代码逻辑动态添加到代理中。</p>\n<p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>\n<h3 id=\"h3-u9002u914Du5668u6A21u5F0F\"><a name=\"适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p>\n<p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p>\n<p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p>\n<h4 id=\"h4-u9ED8u8BA4u9002u914Du5668u6A21u5F0F\"><a name=\"默认适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p>\n<p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>\n<pre><code class=\"lang-java\">public interface FileAlterationListener {\n    void onStart(final FileAlterationObserver observer);\n    void onDirectoryCreate(final File directory);\n    void onDirectoryChange(final File directory);\n    void onDirectoryDelete(final File directory);\n    void onFileCreate(final File file);\n    void onFileChange(final File file);\n    void onFileDelete(final File file);\n    void onStop(final FileAlterationObserver observer);\n}\n</code></pre>\n<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>\n<p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>\n<pre><code class=\"lang-java\">public class FileAlterationListenerAdaptor implements FileAlterationListener {\n\n    public void onStart(final FileAlterationObserver observer) {\n    }\n\n    public void onDirectoryCreate(final File directory) {\n    }\n\n    public void onDirectoryChange(final File directory) {\n    }\n\n    public void onDirectoryDelete(final File directory) {\n    }\n\n    public void onFileCreate(final File file) {\n    }\n\n    public void onFileChange(final File file) {\n    }\n\n    public void onFileDelete(final File file) {\n    }\n\n    public void onStop(final FileAlterationObserver observer) {\n    }\n}\n</code></pre>\n<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>\n<pre><code class=\"lang-java\">public class FileMonitor extends FileAlterationListenerAdaptor {\n    public void onFileCreate(final File file) {\n        // 文件创建\n        doSomething();\n    }\n\n    public void onFileDelete(final File file) {\n        // 文件删除\n        doSomething();\n    }\n}\n</code></pre>\n<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>\n<h4 id=\"h4-u5BF9u8C61u9002u914Du5668u6A21u5F0F\"><a name=\"对象适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>\n<pre><code class=\"lang-java\">public interface Duck {\n    public void quack(); // 鸭的呱呱叫\n    public void fly(); // 飞\n}\n\npublic interface Cock {\n    public void gobble(); // 鸡的咕咕叫\n    public void fly(); // 飞\n}\n\npublic class WildCock implements Cock {\n    public void gobble() {\n        System.out.println(\"咕咕叫\");\n    }\n    public void fly() {\n        System.out.println(\"鸡也会飞哦\");\n    }\n}\n</code></pre>\n<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>\n<pre><code class=\"lang-java\">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用\npublic class CockAdapter implements Duck {\n\n    Cock cock;\n    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用\n      public CockAdapter(Cock cock) {\n        this.cock = cock;\n    }\n\n    // 实现鸭的呱呱叫方法\n    @Override\n      public void quack() {\n        // 内部其实是一只鸡的咕咕叫\n        cock.gobble();\n    }\n\n      @Override\n      public void fly() {\n        cock.fly();\n    }\n}\n</code></pre>\n<p>客户端调用很简单了：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 有一只野鸡\n      Cock wildCock = new WildCock();\n      // 成功将野鸡适配成鸭\n      Duck duck = new CockAdapter(wildCock);\n      ...\n}\n</code></pre>\n<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>\n<p>我们用一个图来简单说明下：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/adapter-1.png\" alt=\"adapter-1\">\n<p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>\n<h4 id=\"h4-u7C7Bu9002u914Du5668u6A21u5F0F\"><a name=\"类适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类适配器模式</h4><p>废话少说，直接上图：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/adapter-2.png\" alt=\"adapter-1\">\n<p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>\n<h4 id=\"h4-u9002u914Du5668u6A21u5F0Fu603Bu7ED3\"><a name=\"适配器模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适配器模式总结</h4><ol>\n<li><p>类适配和对象适配的异同</p>\n<blockquote>\n<p>一个采用继承，一个采用组合；</p>\n<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>\n<p>总体来说，对象适配用得比较多。</p>\n</blockquote>\n</li><li><p>适配器模式和代理模式的异同</p>\n<p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/adapter-5.png\" alt=\"adapter-5\">\n</li></ol>\n<h3 id=\"h3-u6865u6881u6A21u5F0F\"><a name=\"桥梁模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p>\n<p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>\n<pre><code class=\"lang-java\">public interface DrawAPI {\n   public void draw(int radius, int x, int y);\n}\n</code></pre>\n<p>然后是一系列实现类：</p>\n<pre><code class=\"lang-java\">public class RedPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class GreenPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class BluePen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\n</code></pre>\n<p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p>\n<pre><code class=\"lang-java\">public abstract class Shape {\n    protected DrawAPI drawAPI;\n    protected Shape(DrawAPI drawAPI) {\n        this.drawAPI = drawAPI;\n    }\n    public abstract void draw();\n}\n</code></pre>\n<p>定义抽象类的子类：</p>\n<pre><code class=\"lang-java\">// 圆形\npublic class Circle extends Shape {\n    private int radius;\n    public Circle(int radius, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.radius = radius;\n    }\n    public void draw() {\n        drawAPI.draw(radius, 0, 0);\n    }\n}\n// 长方形\npublic class Rectangle extends Shape {\n    private int x;\n    private int y;\n    public Rectangle(int x, int y, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.x = x;\n        this.y = y;\n    }\n    public void draw() {\n        drawAPI.draw(0, x, y);\n    }\n}\n</code></pre>\n<p>最后，我们来看客户端演示：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    Shape greenCircle = new Circle(10, new GreenPen());\n    Shape redRectangle = new Rectangle(4, 8, new RedPen());\n    greenCircle.draw();\n    redRectangle.draw();\n}\n</code></pre>\n<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/bridge-1.png\" alt=\"bridge-1\">\n<p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p>\n<blockquote>\n<p>本节引用了<a href=\"https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm\">这里</a>的例子，并对其进行了修改。</p>\n</blockquote>\n<h3 id=\"h3-u88C5u9970u6A21u5F0F\"><a name=\"装饰模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>\n<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/decorator-1.png\" alt=\"decorator-1\">\n<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p>\n<blockquote>\n<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p>\n</blockquote>\n<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator*</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent<em> 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<em>*加了层皮来装饰</em></em>而已。</p>\n<blockquote>\n<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>\n</blockquote>\n<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>\n<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>\n<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>\n<p>不说废话了，上代码。</p>\n<p>首先，定义饮料抽象基类：</p>\n<pre><code class=\"lang-java\">public abstract class Beverage {\n      // 返回描述\n      public abstract String getDescription();\n      // 返回价格\n      public abstract double cost();\n}\n</code></pre>\n<p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p>\n<pre><code class=\"lang-java\">public class BlackTea extends Beverage {\n      public String getDescription() {\n        return \"红茶\";\n    }\n      public double cost() {\n        return 10;\n    }\n}\npublic class GreenTea extends Beverage {\n    public String getDescription() {\n        return \"绿茶\";\n    }\n      public double cost() {\n        return 11;\n    }\n}\n...// 咖啡省略\n</code></pre>\n<p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p>\n<pre><code class=\"lang-java\">// 调料\npublic abstract class Condiment extends Beverage {\n\n}\n</code></pre>\n<p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p>\n<pre><code class=\"lang-java\">public class Lemon extends Condiment {\n    private Beverage bevarage;\n    // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，\n    // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶\n    public Lemon(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        // 装饰\n        return bevarage.getDescription() + \", 加柠檬\";\n    }\n    public double cost() {\n        // 装饰\n        return beverage.cost() + 2; // 加柠檬需要 2 元\n    }\n}\n\npublic class Mango extends Condiment {\n    private Beverage bevarage;\n    public Mango(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        return bevarage.getDescription() + \", 加芒果\";\n    }\n    public double cost() {\n        return beverage.cost() + 3; // 加芒果需要 3 元\n    }\n}\n...// 给每一种调料都加一个类\n</code></pre>\n<p>看客户端调用：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡\n    Beverage beverage = new GreenTea();\n    // 开始装饰\n    beverage = new Lemon(beverage); // 先加一份柠檬\n    beverage = new Mongo(beverage); // 再加一份芒果\n\n    System.out.println(beverage.getDescription() + \" 价格：￥\" + beverage.cost());\n    //\"绿茶, 加柠檬, 加芒果 价格：￥16\"\n}\n</code></pre>\n<p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p>\n<pre><code class=\"lang-java\">Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));\n</code></pre>\n<p>是不是很变态？</p>\n<p>看看下图可能会清晰一些：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/decorator-2.png\" alt=\"decorator-2\">\n<p>到这里，大家应该已经清楚装饰模式了吧。</p>\n<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/decorator-3.png\" alt=\"decorator-3\">\n<p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>\n<p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>\n<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>\n<pre><code class=\"lang-java\">InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(\"\")));\n</code></pre>\n<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>\n<p>我们应该像下面这样使用：</p>\n<pre><code class=\"lang-java\">DataInputStream is = new DataInputStream(\n                              new BufferedInputStream(\n                                  new FileInputStream(\"\")));\n</code></pre>\n<blockquote>\n<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>\n</blockquote>\n<h3 id=\"h3-u95E8u9762u6A21u5F0F\"><a name=\"门面模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p>\n<p>首先，我们定义一个接口：</p>\n<pre><code class=\"lang-java\">public interface Shape {\n   void draw();\n}\n</code></pre>\n<p>定义几个实现类：</p>\n<pre><code class=\"lang-java\">public class Circle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Rectangle::draw()\");\n    }\n}\n</code></pre>\n<p>客户端调用：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 画一个圆形\n      Shape circle = new Circle();\n      circle.draw();\n\n      // 画一个长方形\n      Shape rectangle = new Rectangle();\n      rectangle.draw();\n}\n</code></pre>\n<p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p>\n<p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p>\n<p>我们先定义一个门面：</p>\n<pre><code class=\"lang-java\">public class ShapeMaker {\n   private Shape circle;\n   private Shape rectangle;\n   private Shape square;\n\n   public ShapeMaker() {\n      circle = new Circle();\n      rectangle = new Rectangle();\n      square = new Square();\n   }\n\n  /**\n   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定\n   */\n\n   public void drawCircle(){\n      circle.draw();\n   }\n   public void drawRectangle(){\n      rectangle.draw();\n   }\n   public void drawSquare(){\n      square.draw();\n   }\n}\n</code></pre>\n<p>看看现在客户端怎么调用：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n  ShapeMaker shapeMaker = new ShapeMaker();\n\n  // 客户端调用现在更加清晰了\n  shapeMaker.drawCircle();\n  shapeMaker.drawRectangle();\n  shapeMaker.drawSquare();        \n}\n</code></pre>\n<p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p>\n<h3 id=\"h3-u7EC4u5408u6A21u5F0F\"><a name=\"组合模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p>\n<p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p>\n<pre><code class=\"lang-java\">public class Employee {\n   private String name;\n   private String dept;\n   private int salary;\n   private List&lt;Employee&gt; subordinates; // 下属\n\n   public Employee(String name,String dept, int sal) {\n      this.name = name;\n      this.dept = dept;\n      this.salary = sal;\n      subordinates = new ArrayList&lt;Employee&gt;();\n   }\n\n   public void add(Employee e) {\n      subordinates.add(e);\n   }\n\n   public void remove(Employee e) {\n      subordinates.remove(e);\n   }\n\n   public List&lt;Employee&gt; getSubordinates(){\n     return subordinates;\n   }\n\n   public String toString(){\n      return (\"Employee :[ Name : \" + name + \", dept : \" + dept + \", salary :\" + salary+\" ]\");\n   }   \n}\n</code></pre>\n<p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p>\n<p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p>\n<h3 id=\"h3-u4EABu5143u6A21u5F0F\"><a name=\"享元模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p>\n<p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p>\n<p>这种简单的代码我就不演示了。</p>\n<h3 id=\"h3-u7ED3u6784u578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"结构型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p>\n<p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>\n<h2 id=\"h2-u884Cu4E3Au578Bu6A21u5F0F\"><a name=\"行为型模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p>\n<h3 id=\"h3-u7B56u7565u6A21u5F0F\"><a name=\"策略模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p>\n<p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p>\n<p>首先，先定义一个策略接口：</p>\n<pre><code class=\"lang-java\">public interface Strategy {\n   public void draw(int radius, int x, int y);\n}\n</code></pre>\n<p>然后我们定义具体的几个策略：</p>\n<pre><code class=\"lang-java\">public class RedPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class GreenPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class BluePen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\n</code></pre>\n<p>使用策略的类：</p>\n<pre><code class=\"lang-java\">public class Context {\n   private Strategy strategy;\n\n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n\n   public int executeDraw(int radius, int x, int y){\n      return strategy.draw(radius, x, y);\n   }\n}\n</code></pre>\n<p>客户端演示：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    Context context = new Context(new BluePen()); // 使用绿色笔来画\n      context.executeDraw(10, 0, 0);\n}\n</code></pre>\n<p>放到一张图上，让大家看得清晰些：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/strategy-1.png\" alt=\"strategy-1\">\n<p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p>\n<p><img src=\"https://www.javadoop.com/blogimages/design-pattern/bridge-1.png\" alt=\"bridge-1\">\n<p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p>\n<h3 id=\"h3-u89C2u5BDFu8005u6A21u5F0F\"><a name=\"观察者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p>\n<p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p>\n<pre><code class=\"lang-java\">public class Subject {\n    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();\n    private int state;\n    public int getState() {\n        return state;\n    }\n    public void setState(int state) {\n        this.state = state;\n        // 数据已变更，通知观察者们\n        notifyAllObservers();\n    }\n    // 注册观察者\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    // 通知观察者们\n    public void notifyAllObservers() {\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n</code></pre>\n<p>定义观察者接口：</p>\n<pre><code class=\"lang-java\">public abstract class Observer {\n    protected Subject subject;\n    public abstract void update();\n}\n</code></pre>\n<p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p>\n<p>我们来定义具体的几个观察者类：</p>\n<pre><code class=\"lang-java\">public class BinaryObserver extends Observer {\n    // 在构造方法中进行订阅主题\n    public BinaryObserver(Subject subject) {\n        this.subject = subject;\n        // 通常在构造方法中将 this 发布出去的操作一定要小心\n        this.subject.attach(this);\n    }\n    // 该方法由主题类在数据变更的时候进行调用\n    @Override\n    public void update() {\n        String result = Integer.toBinaryString(subject.getState());\n        System.out.println(\"订阅的数据发生变化，新的数据处理为二进制值为：\" + result);\n    }\n}\n\npublic class HexaObserver extends Observer {\n    public HexaObserver(Subject subject) {\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        String result = Integer.toHexString(subject.getState()).toUpperCase();\n        System.out.println(\"订阅的数据发生变化，新的数据处理为十六进制值为：\" + result);\n    }\n}\n</code></pre>\n<p>客户端使用也非常简单：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 先定义一个主题\n    Subject subject1 = new Subject();\n    // 定义观察者\n    new BinaryObserver(subject1);\n    new HexaObserver(subject1);\n\n    // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用\n    subject.setState(11);\n}\n</code></pre>\n<p>output:</p>\n<pre><code>订阅的数据发生变化，新的数据处理为二进制值为：1011\n订阅的数据发生变化，新的数据处理为十六进制值为：B\n</code></pre><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p>\n<p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p>\n<p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p>\n<h3 id=\"h3-u8D23u4EFBu94FEu6A21u5F0F\"><a name=\"责任链模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p>\n<p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p>\n<blockquote>\n<p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p>\n</blockquote>\n<p>首先，我们要定义流程上节点的基类：</p>\n<pre><code class=\"lang-java\">public abstract class RuleHandler {\n    // 后继节点\n    protected RuleHandler successor;\n\n    public abstract void apply(Context context);\n\n    public void setSuccessor(RuleHandler successor) {\n        this.successor = successor;\n    }\n\n    public RuleHandler getSuccessor() {\n        return successor;\n    }\n}\n</code></pre>\n<p>接下来，我们需要定义具体的每个节点了。</p>\n<p>校验用户是否是新用户：</p>\n<pre><code class=\"lang-java\">public class NewUserRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        if (context.isNewUser()) {\n            // 如果有后继节点的话，传递下去\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"该活动仅限新用户参与\");\n        }\n    }\n}\n</code></pre>\n<p>校验用户所在地区是否可以参与：</p>\n<pre><code class=\"lang-java\">public class LocationRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        boolean allowed = activityService.isSupportedLocation(context.getLocation);\n        if (allowed) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"非常抱歉，您所在的地区无法参与本次活动\");\n        }\n    }\n}\n</code></pre>\n<p>校验奖品是否已领完：</p>\n<pre><code class=\"lang-java\">public class LimitRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品\n        if (remainedTimes &gt; 0) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(userInfo);\n            }\n        } else {\n            throw new RuntimeException(\"您来得太晚了，奖品被领完了\");\n        }\n    }\n}\n</code></pre>\n<p>客户端：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    RuleHandler newUserHandler = new NewUserRuleHandler();\n    RuleHandler locationHandler = new LocationRuleHandler();\n    RuleHandler limitHandler = new LimitRuleHandler();\n\n    // 假设本次活动仅校验地区和奖品数量，不校验新老用户\n    locationHandler.setSuccessor(limitHandler);\n\n    locationHandler.apply(context);\n}\n</code></pre>\n<p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p>\n<p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>\n<h3 id=\"h3-u6A21u677Fu65B9u6CD5u6A21u5F0F\"><a name=\"模板方法模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>\n<p>通常会有一个抽象类：</p>\n<pre><code class=\"lang-java\">public abstract class AbstractTemplate {\n    // 这就是模板方法\n    public void templateMethod() {\n        init();\n        apply(); // 这个是重点\n        end(); // 可以作为钩子方法\n    }\n\n    protected void init() {\n        System.out.println(\"init 抽象层已经实现，子类也可以选择覆写\");\n    }\n\n    // 留给子类实现\n    protected abstract void apply();\n\n    protected void end() {\n    }\n}\n</code></pre>\n<p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>\n<p>我们写一个实现类：</p>\n<pre><code class=\"lang-java\">public class ConcreteTemplate extends AbstractTemplate {\n    public void apply() {\n        System.out.println(\"子类实现抽象方法 apply\");\n    }\n\n    public void end() {\n        System.out.println(\"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了\");\n    }\n}\n</code></pre>\n<p>客户端调用演示：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    AbstractTemplate t = new ConcreteTemplate();\n    // 调用模板方法\n    t.templateMethod();\n}\n</code></pre>\n<p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p>\n<h3 id=\"h3-u72B6u6001u6A21u5F0F\"><a name=\"状态模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>状态模式</h3><p>update: 2017-10-19</p>\n<p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p>\n<p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p>\n<p>定义状态接口：</p>\n<pre><code class=\"lang-java\">public interface State {\n    public void doAction(Context context);\n}\n</code></pre>\n<p>定义减库存的状态：</p>\n<pre><code class=\"lang-java\">public class DeductState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"商品卖出，准备减库存\");\n        context.setState(this);\n\n        //... 执行减库存的具体操作\n    }\n\n    public String toString() {\n        return \"Deduct State\";\n    }\n}\n</code></pre>\n<p>定义补库存状态：</p>\n<pre><code class=\"lang-java\">public class RevertState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"给此商品补库存\");\n        context.setState(this);\n\n        //... 执行加库存的具体操作\n    }\n\n    public String toString() {\n        return \"Revert State\";\n    }\n}\n</code></pre>\n<p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p>\n<pre><code class=\"lang-java\">public class Context {\n    private State state;\n      private String name;\n      public Context(String name) {\n        this.name = name;\n    }\n\n      public void setState(State state) {\n        this.state = state;\n    }\n      public void getState() {\n        return this.state;\n    }\n}\n</code></pre>\n<p>我们来看下客户端调用，大家就一清二楚了：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    // 我们需要操作的是 iPhone X\n    Context context = new Context(\"iPhone X\");\n\n    // 看看怎么进行补库存操作\n      State revertState = new RevertState();\n      revertState.doAction(context);\n\n    // 同样的，减库存操作也非常简单\n      State deductState = new DeductState();\n      deductState.doAction(context);\n\n      // 如果需要我们可以获取当前的状态\n    // context.getState().toString();\n}\n</code></pre>\n<p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p>\n<p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p>\n<h3 id=\"h3-u884Cu4E3Au578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"行为型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。</p>\n', '设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 *Gang of Four* (*GoF*) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。\n\n有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：\n\n1. 面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。\n2. 职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。\n3. 对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。\n\n**创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。**\n\n## 创建型模式\n\n创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。\n\n### 简单工厂模式\n\n和名字一样简单，非常简单，直接上代码吧：\n\n```java\npublic class FoodFactory {\n\n    public static Food makeFood(String name) {\n        if (name.equals(\"noodle\")) {\n            Food noodle = new LanZhouNoodle();\n            noodle.addSpicy(\"more\");\n            return noodle;\n        } else if (name.equals(\"chicken\")) {\n            Food chicken = new HuangMenChicken();\n            chicken.addCondiment(\"potato\");\n            return chicken;\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n*其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。*\n\n简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。\n\n> 我们强调**职责单一**原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。\n\n### 工厂模式\n\n简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。\n\n```java\npublic interface FoodFactory {\n    Food makeFood(String name);\n}\npublic class ChineseFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new ChineseFoodA();\n        } else if (name.equals(\"B\")) {\n            return new ChineseFoodB();\n        } else {\n            return null;\n        }\n    }\n}\npublic class AmericanFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new AmericanFoodA();\n        } else if (name.equals(\"B\")) {\n            return new AmericanFoodB();\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。\n\n客户端调用：\n\n```java\npublic class APP {\n    public static void main(String[] args) {\n        // 先选择一个具体的工厂\n        FoodFactory factory = new ChineseFoodFactory();\n        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象\n        Food food = factory.makeFood(\"A\");\n    }\n}\n```\n\n虽然都是调用 makeFood(\"A\")  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。\n\n第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。\n\n**核心在于，我们需要在第一步选好我们需要的工厂**。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。\n\n虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：\n\n![factory-1](https://www.javadoop.com/blogimages/design-pattern/factory-1.png)\n\n### 抽象工厂模式\n\n当涉及到**产品族**的时候，就需要引入抽象工厂模式了。\n\n一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。\n\n因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：\n\n![factory-1](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png)\n\n这个时候的客户端调用是这样的：\n\n```java\n// 得到 Intel 的 CPU\nCPUFactory cpuFactory = new IntelCPUFactory();\nCPU cpu = intelCPUFactory.makeCPU();\n\n// 得到 AMD 的主板\nMainBoardFactory mainBoardFactory = new AmdMainBoardFactory();\nMainBoard mainBoard = mainBoardFactory.make();\n\n// 组装 CPU 和主板\nComputer computer = new Computer(cpu, mainBoard);\n```\n\n单独看 CPU 工厂和主板工厂，它们分别是前面我们说的**工厂模式**。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。\n\n但是，这种方式有一个问题，那就是如果 **Intel 家产的 CPU 和 AMD 产的主板不能兼容使用**，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。\n\n下面就是我们要说的**产品族**的概念，它代表了组成某个产品的一系列附件的集合：\n\n![abstract-factory-2](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png)\n\n当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。\n\n![abstract-factory-3](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png)\n\n这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。\n\n```java\npublic static void main(String[] args) {\n    // 第一步就要选定一个“大厂”\n    ComputerFactory cf = new AmdFactory();\n    // 从这个大厂造 CPU\n    CPU cpu = cf.makeCPU();\n    // 从这个大厂造主板\n    MainBoard board = cf.makeMainBoard();\n  	// 从这个大厂造硬盘\n  	HardDisk hardDisk = cf.makeHardDisk();\n  \n    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起\n    Computer result = new Computer(cpu, board, hardDisk);\n}\n```\n\n当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了**对修改关闭，对扩展开放**这个设计原则。\n\n### 单例模式\n\n单例模式用得最多，错得最多。\n\n饿汉模式最简单：\n\n```java\npublic class Singleton {\n    // 首先，将 new Singleton() 堵死\n    private Singleton() {};\n    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建\n    private static Singleton instance = new Singleton();\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，\n    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了\n    public static Date getDate(String mode) {return new Date();}\n}\n```\n\n> 很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。\n\n饱汉模式最容易出错：\n\n```java\npublic class Singleton {\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() {}\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            // 加锁\n            synchronized (Singleton.class) {\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n> 双重检查，指的是两次检查 instance 是否为 null。\n>\n> volatile 在这里是需要的，希望能引起读者的关注。\n>\n> 很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。\n\n嵌套类最经典，以后大家就用它吧：\n\n```java\npublic class Singleton3 {\n\n    private Singleton3() {}\n    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性\n    private static class Holder {\n        private static Singleton3 instance = new Singleton3();\n    }\n    public static Singleton3 getInstance() {\n        return Holder.instance;\n    }\n}\n```\n\n> 注意，很多人都会把这个**嵌套类**说成是**静态内部类**，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。\n\n最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。\n\n虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。\n\n### 建造者模式\n\n经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：\n\n```java\nFood food = new FoodBuilder().a().b().c().build();\nFood food = Food.builder().a().b().c().build();\n```\n\n套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。\n\n来一个中规中矩的建造者模式：\n\n```java\nclass User {\n    // 下面是“一堆”的属性\n    private String name;\n    private String password;\n    private String nickName;\n    private int age;\n\n    // 构造方法私有化，不然客户端就会直接调用构造方法了\n    private User(String name, String password, String nickName, int age) {\n        this.name = name;\n        this.password = password;\n        this.nickName = nickName;\n        this.age = age;\n    }\n	// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，\n    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好\n    public static UserBuilder builder() {\n        return new UserBuilder();\n    }\n   \n    public static class UserBuilder {\n        // 下面是和 User 一模一样的一堆属性\n        private String  name;\n        private String password;\n        private String nickName;\n        private int age;\n\n        private UserBuilder() {\n        }\n\n        // 链式调用设置各个属性值，返回 this，即 UserBuilder\n        public UserBuilder name(String name) {\n            this.name = name;\n            return this;\n        }\n\n        public UserBuilder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n        public UserBuilder nickName(String nickName) {\n            this.nickName = nickName;\n            return this;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。\n        // 当然，可以在 “复制” 之前做点检验\n        public User build() {\n            if (name == null || password == null) {\n                throw new RuntimeException(\"用户名和密码必填\");\n            }\n            if (age <= 0 || age >= 150) {\n                throw new RuntimeException(\"年龄不合法\");\n            }\n            // 还可以做赋予”默认值“的功能\n          	if (nickName == null) {\n                nickName = name;\n            }\n            return new User(name, password, nickName, age);\n        }\n    }\n}\n```\n\n核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性**复制**给实际产生的对象。\n\n看看客户端的调用：\n\n```java\npublic class APP {\n    public static void main(String[] args) {\n        User d = User.builder()\n                .name(\"foo\")\n                .password(\"pAss12345\")\n                .age(25)\n                .build();\n    }\n}\n```\n\n说实话，建造者模式的**链式**写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 **Builder 的构造方法**中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。\n\n> 题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:\n\n```java\n@Builder\nclass User {\n    private String  name;\n    private String password;\n    private String nickName;\n    private int age;\n}\n```\n\n> 怎么样，省下来的时间是不是又可以干点别的了。\n\n当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 **return this** 就可以了，然后就可以像下面这样调用：\n\n```java\nUser user = new User().setName(\"\").setPassword(\"\").setAge(20);\n```\n\n> 很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。\n\n### 原型模式\n\n这是我要说的创建型模式的最后一个设计模式了。\n\n原型模式很简单：有一个原型**实例**，基于这个原型实例产生新的实例，也就是“克隆”了。\n\nObject 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先**实现 Cloneable 接口**，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。\n\n```java\nprotected native Object clone() throws CloneNotSupportedException;\n```\n\n> java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。\n\n原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。\n\n### 创建型模式总结\n\n创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是**面向对象**的代码，所以我们第一步当然是需要创建一个对象了。\n\n简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。\n\n## 结构型模式\n\n前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。\n\n### 代理模式\n\n第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。\n\n既然说是**代理**，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。\n\n> 理解**代理**这个词，这个模式其实就简单了。\n\n```java\npublic interface FoodService {\n    Food makeChicken();\n    Food makeNoodle();\n}\n\npublic class FoodServiceImpl implements FoodService {\n    public Food makeChicken() {\n      	Food f = new Chicken()\n        f.setChicken(\"1kg\");\n      	f.setSpicy(\"1g\");\n      	f.setSalt(\"3g\");\n        return f;\n    }\n    public Food makeNoodle() {\n        Food f = new Noodle();\n        f.setNoodle(\"500g\");\n        f.setSalt(\"5g\");\n        return f;\n    }\n}\n\n// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService\npublic class FoodServiceProxy implements FoodService {\n  \n    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入\n    private FoodService foodService = new FoodServiceImpl();\n    \n    public Food makeChicken() {\n        System.out.println(\"我们马上要开始制作鸡肉了\");\n      \n        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，\n        // 代理只是在核心代码前后做些“无足轻重”的事情\n        Food food = foodService.makeChicken();\n      \n        System.out.println(\"鸡肉制作完成啦，加点胡椒粉\"); // 增强\n      	food.addCondiment(\"pepper\");\n      \n        return food;\n    }\n    public Food makeNoodle() {\n        System.out.println(\"准备制作拉面~\");\n        Food food = foodService.makeNoodle();\n        System.out.println(\"制作完成啦\")\n        return food;\n    }\n}\n```\n\n客户端调用，注意，我们要用代理来实例化接口：\n\n```java\n// 这里用代理类来实例化\nFoodService foodService = new FoodServiceProxy();\nfoodService.makeChicken();\n```\n\n![proxy](https://www.javadoop.com/blogimages/design-pattern/proxy-1.png)\n\n我们发现没有，代理模式说白了就是做 **“方法包装”** 或做 **“方法增强”**。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。\n\n说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。\n\n### 适配器模式\n\n说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。\n\n适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。\n\n适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。\n\n#### 默认适配器模式\n\n首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。\n\n我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。\n\n```java\npublic interface FileAlterationListener {\n    void onStart(final FileAlterationObserver observer);\n    void onDirectoryCreate(final File directory);\n    void onDirectoryChange(final File directory);\n    void onDirectoryDelete(final File directory);\n    void onFileCreate(final File file);\n    void onFileChange(final File file);\n    void onFileDelete(final File file);\n    void onStop(final FileAlterationObserver observer);\n}\n```\n\n此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的**文件创建**和**文件删除**事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。\n\n所以，我们需要下面的一个**适配器**，它用于实现上面的接口，但是**所有的方法都是空方法**，这样，我们就可以转而定义自己的类来继承下面这个类即可。\n\n```java\npublic class FileAlterationListenerAdaptor implements FileAlterationListener {\n\n    public void onStart(final FileAlterationObserver observer) {\n    }\n\n    public void onDirectoryCreate(final File directory) {\n    }\n\n    public void onDirectoryChange(final File directory) {\n    }\n\n    public void onDirectoryDelete(final File directory) {\n    }\n\n    public void onFileCreate(final File file) {\n    }\n\n    public void onFileChange(final File file) {\n    }\n\n    public void onFileDelete(final File file) {\n    }\n\n    public void onStop(final FileAlterationObserver observer) {\n    }\n}\n```\n\n比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：\n\n```java\npublic class FileMonitor extends FileAlterationListenerAdaptor {\n    public void onFileCreate(final File file) {\n        // 文件创建\n        doSomething();\n    }\n\n    public void onFileDelete(final File file) {\n        // 文件删除\n        doSomething();\n    }\n}\n```\n\n当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍**“正统的”**适配器模式。\n\n#### 对象适配器模式\n\n来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。\n\n```java\npublic interface Duck {\n    public void quack(); // 鸭的呱呱叫\n    public void fly(); // 飞\n}\n\npublic interface Cock {\n    public void gobble(); // 鸡的咕咕叫\n    public void fly(); // 飞\n}\n\npublic class WildCock implements Cock {\n    public void gobble() {\n        System.out.println(\"咕咕叫\");\n    }\n    public void fly() {\n        System.out.println(\"鸡也会飞哦\");\n    }\n}\n```\n\n鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：\n\n```java\n// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用\npublic class CockAdapter implements Duck {\n  \n    Cock cock;\n    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用\n  	public CockAdapter(Cock cock) {\n        this.cock = cock;\n    }\n  \n    // 实现鸭的呱呱叫方法\n    @Override\n  	public void quack() {\n        // 内部其实是一只鸡的咕咕叫\n        cock.gobble();\n    }\n  \n  	@Override\n  	public void fly() {\n        cock.fly();\n    }\n}\n```\n\n客户端调用很简单了：\n\n```java\npublic static void main(String[] args) {\n    // 有一只野鸡\n  	Cock wildCock = new WildCock();\n  	// 成功将野鸡适配成鸭\n  	Duck duck = new CockAdapter(wildCock);\n  	...\n}\n```\n\n到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。\n\n我们用一个图来简单说明下：\n\n![adapter-1](https://www.javadoop.com/blogimages/design-pattern/adapter-1.png)\n\n上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。\n\n#### 类适配器模式\n\n废话少说，直接上图：\n\n![adapter-1](https://www.javadoop.com/blogimages/design-pattern/adapter-2.png)\n\n看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 `Target t = new SomeAdapter();` 就可以了。\n\n#### 适配器模式总结\n\n1. 类适配和对象适配的异同\n\n   > 一个采用继承，一个采用组合；\n   >\n   > 类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。\n   >\n   > 总体来说，对象适配用得比较多。\n\n2. 适配器模式和代理模式的异同\n\n   比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。\n\n   ![adapter-5](https://www.javadoop.com/blogimages/design-pattern/adapter-5.png)\n\n### 桥梁模式\n\n理解桥梁模式，其实就是理解代码抽象和解耦。\n\n我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。\n\n```java\npublic interface DrawAPI {\n   public void draw(int radius, int x, int y);\n}\n```\n\n然后是一系列实现类：\n\n```java\npublic class RedPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class GreenPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class BluePen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\n```\n\n定义一个抽象类，此类的实现类都需要使用 DrawAPI：\n\n```java\npublic abstract class Shape {\n    protected DrawAPI drawAPI;\n    protected Shape(DrawAPI drawAPI) {\n        this.drawAPI = drawAPI;\n    }\n    public abstract void draw();\n}\n```\n\n定义抽象类的子类：\n\n```java\n// 圆形\npublic class Circle extends Shape {\n    private int radius;\n    public Circle(int radius, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.radius = radius;\n    }\n    public void draw() {\n        drawAPI.draw(radius, 0, 0);\n    }\n}\n// 长方形\npublic class Rectangle extends Shape {\n    private int x;\n    private int y;\n    public Rectangle(int x, int y, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.x = x;\n        this.y = y;\n    }\n    public void draw() {\n        drawAPI.draw(0, x, y);\n    }\n}\n```\n\n最后，我们来看客户端演示：\n\n```java\npublic static void main(String[] args) {\n    Shape greenCircle = new Circle(10, new GreenPen());\n    Shape redRectangle = new Rectangle(4, 8, new RedPen());\n    greenCircle.draw();\n    redRectangle.draw();\n}\n```\n\n可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：\n\n![bridge-1](https://www.javadoop.com/blogimages/design-pattern/bridge-1.png)\n\n这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。\n\n> 本节引用了[这里](https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm)的例子，并对其进行了修改。\n\n### 装饰模式\n\n要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 **Java IO** 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。\n\n首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：\n\n![decorator-1](https://www.javadoop.com/blogimages/design-pattern/decorator-1.png)\n\n我们来说说装饰模式的出发点，从图中可以看到，接口 `Component` 其实已经有了 `ConcreteComponentA` 和 `ConcreteComponentB` 两个实现类了，但是，如果我们要**增强**这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来**装饰**实现类，以达到增强的目的。\n\n> 从名字来简单解释下装饰器。既然说是装饰，那么往往就是**添加小功能**这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。\n\n首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 **ConcreteDecorator*** 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起**装饰**作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中**加了层皮来装饰**而已。\n\n> 注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。\n\n下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。\n\n最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。\n\n在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea......但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？\n\n不说废话了，上代码。\n\n首先，定义饮料抽象基类：\n\n```java\npublic abstract class Beverage {\n  	// 返回描述\n  	public abstract String getDescription();\n  	// 返回价格\n  	public abstract double cost();\n}\n```\n\n然后是三个基础饮料实现类，红茶、绿茶和咖啡：\n\n```java\npublic class BlackTea extends Beverage {\n  	public String getDescription() {\n        return \"红茶\";\n    }\n  	public double cost() {\n        return 10;\n    }\n}\npublic class GreenTea extends Beverage {\n    public String getDescription() {\n        return \"绿茶\";\n    }\n  	public double cost() {\n        return 11;\n    }\n}\n...// 咖啡省略\n```\n\n定义调料，也就是装饰者的基类，此类必须继承自 Beverage：\n\n```java\n// 调料\npublic abstract class Condiment extends Beverage {\n    \n}\n```\n\n然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：\n\n```java\npublic class Lemon extends Condiment {\n    private Beverage bevarage;\n    // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，\n    // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶\n    public Lemon(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        // 装饰\n        return bevarage.getDescription() + \", 加柠檬\";\n    }\n    public double cost() {\n        // 装饰\n        return beverage.cost() + 2; // 加柠檬需要 2 元\n    }\n}\n\npublic class Mango extends Condiment {\n    private Beverage bevarage;\n    public Mango(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        return bevarage.getDescription() + \", 加芒果\";\n    }\n    public double cost() {\n        return beverage.cost() + 3; // 加芒果需要 3 元\n    }\n}\n...// 给每一种调料都加一个类\n```\n\n看客户端调用：\n\n```java\npublic static void main(String[] args) {\n    // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡\n    Beverage beverage = new GreenTea();\n    // 开始装饰\n    beverage = new Lemon(beverage); // 先加一份柠檬\n    beverage = new Mongo(beverage); // 再加一份芒果\n\n    System.out.println(beverage.getDescription() + \" 价格：￥\" + beverage.cost());\n    //\"绿茶, 加柠檬, 加芒果 价格：￥16\"\n}\n```\n\n如果我们需要 **芒果-珍珠-双份柠檬-红茶**：\n\n```java\nBeverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));\n```\n\n是不是很变态？\n\n看看下图可能会清晰一些：\n\n![decorator-2](https://www.javadoop.com/blogimages/design-pattern/decorator-2.png)\n\n到这里，大家应该已经清楚装饰模式了吧。\n\n下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：\n\n![decorator-3](https://www.javadoop.com/blogimages/design-pattern/decorator-3.png)\n\n我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。\n\nFilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。\n\n当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：\n\n```java\nInputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(\"\")));\n```\n\n这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。\n\n我们应该像下面这样使用：\n\n```java\nDataInputStream is = new DataInputStream(\n  							new BufferedInputStream(\n                              	new FileInputStream(\"\")));\n```\n\n> 所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。\n\n### 门面模式\n\n门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。\n\n首先，我们定义一个接口：\n\n```java\npublic interface Shape {\n   void draw();\n}\n```\n\n定义几个实现类：\n\n```java\npublic class Circle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Rectangle::draw()\");\n    }\n}\n```\n\n客户端调用：\n\n```java\npublic static void main(String[] args) {\n    // 画一个圆形\n  	Shape circle = new Circle();\n  	circle.draw();\n  \n  	// 画一个长方形\n  	Shape rectangle = new Rectangle();\n  	rectangle.draw();\n}\n```\n\n以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。\n\n下面，我们看看怎么用门面模式来让客户端调用更加友好一些。\n\n我们先定义一个门面：\n\n```java\npublic class ShapeMaker {\n   private Shape circle;\n   private Shape rectangle;\n   private Shape square;\n\n   public ShapeMaker() {\n      circle = new Circle();\n      rectangle = new Rectangle();\n      square = new Square();\n   }\n\n  /**\n   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定\n   */\n  \n   public void drawCircle(){\n      circle.draw();\n   }\n   public void drawRectangle(){\n      rectangle.draw();\n   }\n   public void drawSquare(){\n      square.draw();\n   }\n}\n```\n\n看看现在客户端怎么调用：\n\n```java\npublic static void main(String[] args) {\n  ShapeMaker shapeMaker = new ShapeMaker();\n\n  // 客户端调用现在更加清晰了\n  shapeMaker.drawCircle();\n  shapeMaker.drawRectangle();\n  shapeMaker.drawSquare();		\n}\n```\n\n门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。\n\n### 组合模式\n\n组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。\n\n直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。\n\n```java\npublic class Employee {\n   private String name;\n   private String dept;\n   private int salary;\n   private List<Employee> subordinates; // 下属\n\n   public Employee(String name,String dept, int sal) {\n      this.name = name;\n      this.dept = dept;\n      this.salary = sal;\n      subordinates = new ArrayList<Employee>();\n   }\n\n   public void add(Employee e) {\n      subordinates.add(e);\n   }\n\n   public void remove(Employee e) {\n      subordinates.remove(e);\n   }\n\n   public List<Employee> getSubordinates(){\n     return subordinates;\n   }\n\n   public String toString(){\n      return (\"Employee :[ Name : \" + name + \", dept : \" + dept + \", salary :\" + salary+\" ]\");\n   }   \n}\n```\n\n通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。\n\n这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。\n\n### 享元模式\n\n英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。\n\n复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。\n\n这种简单的代码我就不演示了。\n\n### 结构型模式总结\n\n前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？\n\n代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。\n\n## 行为型模式\n\n行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。\n\n### 策略模式\n\n策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。\n\n下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。\n\n首先，先定义一个策略接口：\n\n```java\npublic interface Strategy {\n   public void draw(int radius, int x, int y);\n}\n```\n\n然后我们定义具体的几个策略：\n\n```java\npublic class RedPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class GreenPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class BluePen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\n```\n\n使用策略的类：\n\n```java\npublic class Context {\n   private Strategy strategy;\n\n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n\n   public int executeDraw(int radius, int x, int y){\n      return strategy.draw(radius, x, y);\n   }\n}\n```\n\n客户端演示：\n\n```java\npublic static void main(String[] args) {\n    Context context = new Context(new BluePen()); // 使用绿色笔来画\n  	context.executeDraw(10, 0, 0);\n}\n```\n\n放到一张图上，让大家看得清晰些：\n\n![strategy-1](https://www.javadoop.com/blogimages/design-pattern/strategy-1.png)\n\n这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：\n\n![bridge-1](https://www.javadoop.com/blogimages/design-pattern/bridge-1.png)\n\n要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。\n\n### 观察者模式\n\n观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。\n\n首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：\n\n```java\npublic class Subject {\n    private List<Observer> observers = new ArrayList<Observer>();\n    private int state;\n    public int getState() {\n        return state;\n    }\n    public void setState(int state) {\n        this.state = state;\n        // 数据已变更，通知观察者们\n        notifyAllObservers();\n    }\n    // 注册观察者\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    // 通知观察者们\n    public void notifyAllObservers() {\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n```\n\n定义观察者接口：\n\n```java\npublic abstract class Observer {\n    protected Subject subject;\n    public abstract void update();\n}\n```\n\n其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。\n\n我们来定义具体的几个观察者类：\n\n```java\npublic class BinaryObserver extends Observer {\n    // 在构造方法中进行订阅主题\n    public BinaryObserver(Subject subject) {\n        this.subject = subject;\n        // 通常在构造方法中将 this 发布出去的操作一定要小心\n        this.subject.attach(this);\n    }\n    // 该方法由主题类在数据变更的时候进行调用\n    @Override\n    public void update() {\n        String result = Integer.toBinaryString(subject.getState());\n        System.out.println(\"订阅的数据发生变化，新的数据处理为二进制值为：\" + result);\n    }\n}\n\npublic class HexaObserver extends Observer {\n    public HexaObserver(Subject subject) {\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        String result = Integer.toHexString(subject.getState()).toUpperCase();\n        System.out.println(\"订阅的数据发生变化，新的数据处理为十六进制值为：\" + result);\n    }\n}\n```\n\n客户端使用也非常简单：\n\n```java\npublic static void main(String[] args) {\n    // 先定义一个主题\n    Subject subject1 = new Subject();\n    // 定义观察者\n    new BinaryObserver(subject1);\n    new HexaObserver(subject1);\n  \n    // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用\n    subject.setState(11);\n}\n```\n\noutput:\n\n```\n订阅的数据发生变化，新的数据处理为二进制值为：1011\n订阅的数据发生变化，新的数据处理为十六进制值为：B\n```\n\n当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。\n\n实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。\n\n还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。\n\n### 责任链模式\n\n责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。\n\n有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。\n\n> 如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？\n\n首先，我们要定义流程上节点的基类：\n\n```java\npublic abstract class RuleHandler {\n    // 后继节点\n    protected RuleHandler successor;\n  \n    public abstract void apply(Context context);\n  \n    public void setSuccessor(RuleHandler successor) {\n        this.successor = successor;\n    }\n  \n    public RuleHandler getSuccessor() {\n        return successor;\n    }\n}\n```\n\n接下来，我们需要定义具体的每个节点了。\n\n校验用户是否是新用户：\n\n```java\npublic class NewUserRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        if (context.isNewUser()) {\n            // 如果有后继节点的话，传递下去\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"该活动仅限新用户参与\");\n        }\n    }\n}\n```\n\n校验用户所在地区是否可以参与：\n\n```java\npublic class LocationRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        boolean allowed = activityService.isSupportedLocation(context.getLocation);\n        if (allowed) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"非常抱歉，您所在的地区无法参与本次活动\");\n        }\n    }\n}\n```\n\n校验奖品是否已领完：\n\n```java\npublic class LimitRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品\n        if (remainedTimes > 0) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(userInfo);\n            }\n        } else {\n            throw new RuntimeException(\"您来得太晚了，奖品被领完了\");\n        }\n    }\n}\n```\n\n客户端：\n\n```java\npublic static void main(String[] args) {\n    RuleHandler newUserHandler = new NewUserRuleHandler();\n    RuleHandler locationHandler = new LocationRuleHandler();\n    RuleHandler limitHandler = new LimitRuleHandler();\n  \n    // 假设本次活动仅校验地区和奖品数量，不校验新老用户\n    locationHandler.setSuccessor(limitHandler);\n  \n    locationHandler.apply(context);\n}\n```\n\n代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。\n\n至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。\n\n### 模板方法模式\n\n在含有继承结构的代码中，模板方法模式是非常常用的。\n\n通常会有一个抽象类：\n\n```java\npublic abstract class AbstractTemplate {\n    // 这就是模板方法\n    public void templateMethod() {\n        init();\n        apply(); // 这个是重点\n        end(); // 可以作为钩子方法\n    }\n\n    protected void init() {\n        System.out.println(\"init 抽象层已经实现，子类也可以选择覆写\");\n    }\n\n    // 留给子类实现\n    protected abstract void apply();\n\n    protected void end() {\n    }\n}\n```\n\n模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。\n\n我们写一个实现类：\n\n```java\npublic class ConcreteTemplate extends AbstractTemplate {\n    public void apply() {\n        System.out.println(\"子类实现抽象方法 apply\");\n    }\n\n    public void end() {\n        System.out.println(\"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了\");\n    }\n}\n```\n\n客户端调用演示：\n\n```java\npublic static void main(String[] args) {\n    AbstractTemplate t = new ConcreteTemplate();\n    // 调用模板方法\n    t.templateMethod();\n}\n```\n\n代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。\n\n### 状态模式\n\nupdate: 2017-10-19\n\n废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。\n\n核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。\n\n定义状态接口：\n\n```java\npublic interface State {\n    public void doAction(Context context);\n}\n```\n\n定义减库存的状态：\n\n```java\npublic class DeductState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"商品卖出，准备减库存\");\n        context.setState(this);\n\n        //... 执行减库存的具体操作\n    }\n\n    public String toString() {\n        return \"Deduct State\";\n    }\n} \n```\n\n定义补库存状态：\n\n```java\npublic class RevertState implements State {\n  \n    public void doAction(Context context) {\n        System.out.println(\"给此商品补库存\");\n        context.setState(this);\n\n        //... 执行加库存的具体操作\n    }\n\n    public String toString() {\n        return \"Revert State\";\n    }\n}\n```\n\n前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：\n\n```java\npublic class Context {\n    private State state;\n  	private String name;\n  	public Context(String name) {\n        this.name = name;\n    }\n    \n  	public void setState(State state) {\n        this.state = state;\n    }\n  	public void getState() {\n        return this.state;\n    }\n}\n```\n\n我们来看下客户端调用，大家就一清二楚了：\n\n```java\npublic static void main(String[] args) {\n    // 我们需要操作的是 iPhone X\n    Context context = new Context(\"iPhone X\");\n  	\n    // 看看怎么进行补库存操作\n  	State revertState = new RevertState();\n  	revertState.doAction(context);\n  \n    // 同样的，减库存操作也非常简单\n  	State deductState = new DeductState();\n  	deductState.doAction(context);\n  \n  	// 如果需要我们可以获取当前的状态\n    // context.getState().toString();\n}\n```\n\n读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。\n\n不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。\n\n### 行为型模式总结\n\n行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。\n\n## 总结\n\n 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。', '1', '1', '1', '1', '1', '', '64', 'admin', '2020-03-28 21:52:35', 'admin', '2020-03-28 21:52:35');
INSERT INTO `biz_article` VALUES ('6', '1', '3', '设计模式', '', '', '1', '<h3 id=\"h3-u521Bu5EFAu578B\"><a name=\"创建型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建型</h3><h4 id=\"h4--\"><a name=\"工厂模式(简单工厂，工厂，抽象工厂)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式(简单工厂，工厂，抽象工厂)</h4><h4 id=\"h4-u5355u4F8Bu6A21u5F0F\"><a name=\"单例模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单例模式</h4><h4 id=\"h4-u5EFAu9020u8005u6A21u5F0F\"><a name=\"建造者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>建造者模式</h4><h4 id=\"h4-u539Fu578Bu6A21u5F0F\"><a name=\"原型模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>原型模式</h4><h4 id=\"h4-u521Bu9020u578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"创造型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创造型模式总结</h4><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。</p>\n<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>\n<h3 id=\"h3-u7ED3u6784u578B\"><a name=\"结构型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结构型</h3><h4 id=\"h4-u4EE3u7406u6A21u5F0F\"><a name=\"代理模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式</h4><h4 id=\"h4-u9002u914Du5668u6A21u5F0F\"><a name=\"适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适配器模式</h4><h4 id=\"h4-u6865u6881u6A21u5F0F\"><a name=\"桥梁模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>桥梁模式</h4><h4 id=\"h4-u88C5u9970u6A21u5F0F\"><a name=\"装饰模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>装饰模式</h4><h4 id=\"h4-u95E8u9762u6A21u5F0F\"><a name=\"门面模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>门面模式</h4><h4 id=\"h4-u7EC4u5408u6A21u5F0F\"><a name=\"组合模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>组合模式</h4><h4 id=\"h4-u4EABu5143u6A21u5F0F\"><a name=\"享元模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>享元模式</h4><h4 id=\"h4-u7ED3u6784u578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"结构型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结构型模式总结</h4><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p>\n<p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>\n<h3 id=\"h3-u884Cu4E3Au578B\"><a name=\"行为型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>行为型</h3><h4 id=\"h4-u7B56u7565u6A21u5F0F\"><a name=\"策略模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>策略模式</h4><h4 id=\"h4-u89C2u5BDFu8005u6A21u5F0F\"><a name=\"观察者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>观察者模式</h4><h4 id=\"h4-u8D23u4EFBu94FEu6A21u5F0F\"><a name=\"责任链模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>责任链模式</h4><h4 id=\"h4-u6A21u677Fu65B9u6CD5u6A21u5F0F\"><a name=\"模板方法模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模板方法模式</h4><h4 id=\"h4-u72B6u6001u6A21u5F0F\"><a name=\"状态模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>状态模式</h4><h4 id=\"h4-u884Cu4E3Au578Bu6A21u5F0Fu603Bu7ED3\"><a name=\"行为型模式总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>行为型模式总结</h4><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p>\n<h3 id=\"h3-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h3><p>学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。</p>\n', '### 创建型\n#### 工厂模式(简单工厂，工厂，抽象工厂)\n#### 单例模式\n#### 建造者模式\n#### 原型模式\n#### 创造型模式总结\n创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。\n\n简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。\n\n### 结构型\n#### 代理模式\n#### 适配器模式\n#### 桥梁模式\n#### 装饰模式\n#### 门面模式\n#### 组合模式\n#### 享元模式\n#### 结构型模式总结\n前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？\n\n代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。\n\n### 行为型\n#### 策略模式\n#### 观察者模式\n#### 责任链模式\n#### 模板方法模式\n#### 状态模式\n#### 行为型模式总结\n行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。\n\n### 总结\n学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。', '0', '0', '1', '1', '1', '', '0', 'admin', '2020-03-29 13:50:34', 'admin', '2020-03-29 13:50:34');
INSERT INTO `biz_article` VALUES ('7', '1', '1', 'IntelliJ Idea 一些常用的快捷键', 'IntelliJ Idea 常用快捷键列表', '', '1', '<blockquote>\n<p>【基本快捷键】</p>\n</blockquote>\n<p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行<br><br><br>\n<p>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠\n<blockquote>\n<p>【调试部分、编译】</p>\n</blockquote>\n<p>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器\n<blockquote>\n<p>【重构】<br>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联<br>【查找】<br>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法\n</blockquote>\n', '>【基本快捷键】\n\nCtrl+Shift + Enter，语句完成\n“！”，否定完成，输入表达式时按 “！”键\nCtrl+E，最近的文件\nCtrl+Shift+E，最近更改的文件\nShift+Click，可以关闭文件\nCtrl+[ OR ]，可以跑到大括号的开头与结尾\nCtrl+F12，可以显示当前文件的结构\nCtrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择\nCtrl+N，可以快速打开类\nCtrl+Shift+N，可以快速打开文件\nAlt+Q，可以看到当前方法的声明\nCtrl+P，可以显示参数信息\nCtrl+Shift+Insert，可以选择剪贴板内容并插入\nAlt+Insert，可以生成构造器/Getter/Setter等\nCtrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义\nCtrl+Alt+T，可以把代码包在一个块内，例如：try/catch\nCtrl+Enter，导入包，自动修正\nCtrl+Alt+L，格式化代码\nCtrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作\nCtrl+Alt+O，优化导入的类和包\nCtrl+R，替换文本\nCtrl+F，查找文本\nCtrl+Shift+Space，自动补全代码\nCtrl+空格，代码提示（与系统输入法快捷键冲突）\nCtrl+Shift+Alt+N，查找类中的方法或变量\nAlt+Shift+C，最近的更改\nAlt+Shift+Up/Down，上/下移一行\nShift+F6，重构 – 重命名\nCtrl+X，删除行\nCtrl+D，复制行\nCtrl+/或Ctrl+Shift+/，注释（//或者/**/）\nCtrl+J，自动代码（例如：serr）\nCtrl+Alt+J，用动态模板环绕\nCtrl+H，显示类结构图（类的继承层次）\nCtrl+Q，显示注释文档\nAlt+F1，查找代码所在位置\nAlt+1，快速打开或隐藏工程面板\nCtrl+Alt+left/right，返回至上次浏览的位置\nAlt+left/right，切换代码视图\nAlt+Up/Down，在方法间快速移动定位\nCtrl+Shift+Up/Down，向上/下移动语句\nF2 或 Shift+F2，高亮错误或警告快速定位\nTab，代码标签输入完成后，按 Tab，生成代码\nCtrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失\nAlt+F3，逐个往下查找相同文本，并高亮显示\nCtrl+Up/Down，光标中转到第一行或最后一行下\nCtrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）\nCtrl+Alt+B，跳转到方法实现处\nCtrl+Shift+Backspace，跳转到上次编辑的地方\nCtrl+O，重写方法\nCtrl+Alt+Space，类名自动完成\nCtrl+Alt+Up/Down，快速跳转搜索结果\nCtrl+Shift+J，整合两行\nAlt+F8，计算变量值\nCtrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本\nCtrl+Alt+Shift+V，简单粘贴\nShift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口\nF12，把焦点从编辑器移到最近使用的工具窗口\nShift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器\nCtrl+W，可以选择单词继而语句继而行继而函数\nCtrl+Shift+W，取消选择光标所在词\nAlt+F7，查找整个工程中使用地某一个类、方法或者变量的位置\nCtrl+I，实现方法\nCtrl+Shift+U，大小写转化\nCtrl+Y，删除当前行\n<br><br>\n\nShift+Enter，向下插入新行\npsvm/sout，main/System.out.println(); Ctrl+J，查看更多\nCtrl+Shift+F，全局查找\nCtrl+F，查找/Shift+F3，向上查找/F3，向下查找\nCtrl+Shift+S，高级搜索\nCtrl+U，转到父类\nCtrl+Alt+S，打开设置对话框\nAlt+Shift+Inert，开启/关闭列选择模式\nCtrl+Alt+Shift+S，打开当前项目/模块属性\nCtrl+G，定位行\nAlt+Home，跳转到导航栏\nCtrl+Enter，上插一行\nCtrl+Backspace，按单词删除\nCtrl+”+/-”，当前方法展开、折叠\nCtrl+Shift+”+/-”，全部展开、折叠\n>【调试部分、编译】\n\nCtrl+F2，停止\nAlt+Shift+F9，选择 Debug\nAlt+Shift+F10，选择 Run\nCtrl+Shift+F9，编译\nCtrl+Shift+F10，运行\nCtrl+Shift+F8，查看断点\nF8，步过\nF7，步入\nShift+F7，智能步入\nShift+F8，步出\nAlt+Shift+F8，强制步过\nAlt+Shift+F7，强制步入\nAlt+F9，运行至光标处\nCtrl+Alt+F9，强制运行至光标处\nF9，恢复程序\nAlt+F10，定位到断点\nCtrl+F8，切换行断点\nCtrl+F9，生成项目\nAlt+1，项目\nAlt+2，收藏\nAlt+6，TODO\nAlt+7，结构\nCtrl+Shift+C，复制路径\nCtrl+Alt+Shift+C，复制引用，必须选择类名\nCtrl+Alt+Y，同步\nCtrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）\nShift+F12，还原默认布局\nCtrl+Shift+F12，隐藏/恢复所有窗口\nCtrl+F4，关闭\nCtrl+Shift+F4，关闭活动选项卡\nCtrl+Tab，转到下一个拆分器\nCtrl+Shift+Tab，转到上一个拆分器\n>【重构】\nCtrl+Alt+Shift+T，弹出重构菜单\nShift+F6，重命名\nF6，移动\nF5，复制\nAlt+Delete，安全删除\nCtrl+Alt+N，内联\n>【查找】\nCtrl+F，查找\nCtrl+R，替换\nF3，查找下一个\nShift+F3，查找上一个\nCtrl+Shift+F，在路径中查找\nCtrl+Shift+R，在路径中替换\nCtrl+Shift+S，搜索结构\nCtrl+Shift+M，替换结构\nAlt+F7，查找用法\nCtrl+Alt+F7，显示用法\nCtrl+F7，在文件中查找用法\nCtrl+Shift+F7，在文件中高亮显示用法\n', '1', '0', '1', '1', '1', '', '28', 'admin', '2020-04-19 21:18:56', 'admin', '2020-04-19 21:18:56');
INSERT INTO `biz_article` VALUES ('8', '1', '3', 'Java 字符串常量池介绍', '介绍 HotSpot 中的 String Pool，字符串常量池。相对是一篇比较简单的文章，大家花几分钟就看完了。', '', '1', '<p>本文将介绍 HotSpot 中的 String Pool，字符串常量池。相对是一篇比较简单的文章，大家花几分钟就看完了。</p>\n<p>在 Java 世界中，构造一个 Java 对象是一个相对比较重的活，而且还需要垃圾回收，而缓存池就是为了缓解这个问题的。</p>\n<p>我们来看下基础类型的包装类的缓存，Integer 默认缓存 -128 ~ 127 区间的值，Long 和 Short 也是缓存了这个区间的值，Byte 只能表示 -127 ~ 128 范围的值，全部缓存了，Character 缓存了 0 ~ 127 的值。Float 和 Double 没有缓存的意义。</p>\n<blockquote>\n<p>Integer 可通过设置 java.lang.Integer.IntegerCache.high 扩大缓存区间</p>\n</blockquote>\n<p>String 不是基础类型，但是它也有同样的机制，通过 String Pool 来缓存 String 对象。假设 “Java” 这个字符串我们会在应用程序中使用多次，我们肯定不希望在每次使用到的时候，都重新在堆中创建一个新的对象。</p>\n<blockquote>\n<p>当然，之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是不可变类</p>\n</blockquote>\n<p>基础类型包装类的缓存池使用一个数组进行缓存，而 String 类型，JVM 内部使用 HashTable 进行缓存，我们知道，HashTable 的结构是一个数组，数组中每个元素是一个链表。和我们平时使用的 HashTable 不同，JVM 内部的这个 HashTable 是不可以动态扩容的。</p>\n<p><img src=\"https://assets.javadoop.com/imgs/20510079/string/1.png\" alt=\"1\">\n<h2 id=\"h2-u521Bu5EFAu548Cu56DEu6536\"><a name=\"创建和回收\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建和回收</h2><p>当我们在程序中使用双引号来表示一个字符串时，这个字符串就会进入到 String Pool 中。当然，这里说的是已被加载到 JVM 中的类。</p>\n<blockquote>\n<p>这是一个不够严谨的说法，请参见评论区的讨论。</p>\n</blockquote>\n<p>另外，就是 <strong>String#intern()</strong> 方法，这个方法的作用就是：</p>\n<ul>\n<li>如果字符串未在 Pool 中，那么就往 Pool 中增加一条记录，然后返回 Pool 中的引用。</li><li>如果已经在 Pool 中，直接返回 Pool 中的引用。</li></ul>\n<p>只要 String Pool 中的 String 对象对于 GC Roots 来说不可达，那么它们就是可以被回收的。</p>\n<p>如果 Pool 中对象过多，可能导致 YGC 变长，因为 YGC 的时候，需要扫描 String Pool，可以看看笨神大佬的文章《<a href=\"http://lovestblog.cn/blog/2016/11/06/string-intern/\">JVM源码分析之String.intern()导致的YGC不断变长</a>》。</p>\n<h2 id=\"h2--string-pool-\"><a name=\"讨论 String Pool 的实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>讨论 String Pool 的实现</h2><p><strong>1、首先，我们先考虑 String Pool 的空间问题。</strong></p>\n<p>在 Java 6 中，String Pool 置于 PermGen Space 中，PermGen 有一个问题，那就是它是一个固定大小的区域，虽然我们可以通过 <code>-XX:MaxPermSize=N</code> 来设置永久代的空间大小，但是不管我们设置成多少，它终归是固定的。</p>\n<p>所以，在 Java 6 中，我们应该尽量小心使用 String.intern() 方法，否则容易导致 OutOfMemoryError。</p>\n<p>到了 Java 7，大佬们已经着手去掉 PermGen Space 了，首先，就是将 String Pool 移到了堆中。</p>\n<p>把 String Pool 放到堆中，即使堆的大小也是固定的，但是这个时候，对于应用调优工作，只需要调整堆大小就行了。</p>\n<p><del>到了 Java 8，PermGen 已经被彻底废弃，出现了堆外内存区域 MetaSpace，String Pool 相应的从堆转移到了 MetaSpace 中。</del></p>\n<blockquote>\n<p>在 Java 8 中，String Pool 依然还是在 Heap Space 中。感谢评论区的读者指出错误。大家可以看一下我后面写的关于 MetaSpace 的文章，那篇文章深入分析了 MetaSpace 的构成。</p>\n</blockquote>\n<p><strong>2、其次，我们再讨论 String Pool 的实现问题。</strong></p>\n<p>前面我们说了 String Pool 使用一个 HashTable 来实现，这个 HashTable <strong>不可以扩容</strong>，也就意味着极有可能出现单个 bucket 中的链表很长，导致性能降低。</p>\n<p>在 Java 6 中，这个 HashTable 固定的 bucket 数量是 1009，后来添加了选项（<strong>-XX:StringTableSize=N</strong>）可以配置这个值。到 Java 7（7u40），大佬们提高了这个默认值到 60013，Java 8 依然也是使用这个值，对于绝大部分应用来说，这个值是足够用的。当然，如果你会在代码中大量使用 String#intern()，那么有必要手动设置一下这个值。</p>\n<blockquote>\n<p>为什么是 1009，而不是 1000 或者 1024？因为 1009 是质数，有利于达到更好的散列。60013 同理。</p>\n</blockquote>\n<p> JVM 内部的 HashTable 是不扩容的，但是不代表它不 rehash，它会在发现散列不均匀的时候进行 rehash，这里不展开介绍。</p>\n<p><strong>3、观察 String Pool 的使用情况。</strong></p>\n<p>JVM 提供了 <code>-XX:+PrintStringTableStatistics</code> 启动参数来帮助我们获取统计数据。</p>\n<p>遗憾的是，只有在 JVM 退出的时候，JVM 才会将统计数据打印出来，JVM 没有提供接口给我们实时获取统计数据。</p>\n<pre><code>SymbolTable statistics:\nNumber of buckets       :     20011 =    160088 bytes, avg   8.000\nNumber of entries       :     10923 =    262152 bytes, avg  24.000\nNumber of literals      :     10923 =    425192 bytes, avg  38.926\nTotal footprint         :           =    847432 bytes\nAverage bucket size     :     0.546\nVariance of bucket size :     0.545\nStd. dev. of bucket size:     0.738\nMaximum bucket size     :         6\n## 看下面这部分：\nStringTable statistics:\nNumber of buckets       :     60003 =    480024 bytes, avg   8.000\nNumber of entries       :   4000774 =  96018576 bytes, avg  24.000\nNumber of literals      :   4000774 = 1055252184 bytes, avg 263.762\nTotal footprint         :           = 1151750784 bytes\nAverage bucket size     :    66.676\nVariance of bucket size :    19.843\nStd. dev. of bucket size:     4.455\nMaximum bucket size     :        84\n</code></pre><p>统计数据中包含了 buckets 的数量，总的 String 对象的数量，占用的总空间，单个 bucket 的链表平均长度和最大长度等。</p>\n<p>上面的数据是在 Java 8 的环境中打印出来的，Java 7 的信息稍微少一些，主要是没有 footprint 的数据：</p>\n<pre><code>StringTable statistics:\nNumber of buckets       :   60003\nAverage bucket size     :      67\nVariance of bucket size :      20\nStd. dev. of bucket size:       4\nMaximum bucket size     :      84\n</code></pre><h2 id=\"h2--string-pool-\"><a name=\"测试 String Pool 的性能\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试 String Pool 的性能</h2><p>接下来，我们来跑个测试，测试下 String Pool 的性能问题，并讨论 -XX:StringTableSize=N 参数的作用。</p>\n<p>我们将使用 <code>String#intern()</code> 往字符串常量池中添加 <strong>400万</strong> 个不同的长字符串。</p>\n<pre><code class=\"lang-java\">package com.javadoop;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.WeakHashMap;\n\npublic class StringTest {\n\n    public static void main(String[] args) {\n        test(4000000);\n    }\n\n    private static void test(int cnt) {\n        final List&lt;String&gt; lst = new ArrayList&lt;String&gt;(1024);\n        long start = System.currentTimeMillis();\n        for (int i = 0; i &lt; cnt; ++i) {\n            final String str = \"Very very very very very very very very very very very very very very \" +\n                    \"very long string: \" + i;\n            lst.add(str.intern());\n\n            if (i % 200000 == 0) {\n                System.out.println(i + 200000 + \"; time = \" + (System.currentTimeMillis() - start) / 1000.0 + \" sec\");\n                start = System.currentTimeMillis();\n            }\n        }\n        System.out.println(\"Total length = \" + lst.size());\n    }\n}\n</code></pre>\n<p>我们每插入 20万 条数据，输出一次耗时。</p>\n<pre><code class=\"lang-shell\"># 编译\njavac -d . StringTest.java\n# 使用默认 table size (60013) 运行一次\njava -Xms2g -Xmx2g com.javadoop.StringTest\n# 设置 table size 为 400031，再运行一次\njava -Xms2g -Xmx2g -XX:StringTableSize=400031 com.javadoop.StringTest\n</code></pre>\n<p><img src=\"https://assets.javadoop.com/imgs/20510079/string/2.png\" alt=\"2\">\n<p>从左右两部分数据可以很直观看出来，插入的性能主要取决于链表的平均长度。当链表平均长度为 10 的时候，我们看到性能是几乎没有任何损失的。</p>\n<p>还是那句话，根据自己的实际情况，考虑是否要设置 -XX:StringTableSize=N，还是使用默认值。</p>\n<h2 id=\"h2--string-pool\"><a name=\"讨论自建 String Pool\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>讨论自建 String Pool</h2><p>这一节我们来看下自己使用 HashMap 来实现 String Pool。</p>\n<p>这里我们需要使用 WeakReference：</p>\n<pre><code class=\"lang-java\">private static final WeakHashMap&lt;String, WeakReference&lt;String&gt;&gt; pool\n            = new WeakHashMap&lt;String, WeakReference&lt;String&gt;&gt;(1024);\n\nprivate static String manualIntern(final String str) {\n    final WeakReference&lt;String&gt; cached = pool.get(str);\n    if (cached != null) {\n        final String value = cached.get();\n        if (value != null) {\n            return value;\n        }\n    }\n    pool.put(str, new WeakReference&lt;String&gt;(str));\n    return str;\n}\n</code></pre>\n<p>我们使用 1000 * 1000 * 1000 作为入参 cnt 的值进行测试，分别测试 [1] 和 [2]：</p>\n<pre><code class=\"lang-java\">private static void test(int cnt) {\n    final List&lt;String&gt; lst = new ArrayList&lt;String&gt;(1024);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; cnt; ++i) {\n          // [1]\n        lst.add(String.valueOf(i).intern());\n        // [2]\n        // lst.add(manualIntern(String.valueOf(i)));\n\n        if (i % 200000 == 0) {\n            System.out.println(i + 200000 + \"; time = \" + (System.currentTimeMillis() - start) / 1000.0 + \" sec\");\n            start = System.currentTimeMillis();\n        }\n    }\n    System.out.println(\"Total length = \" + lst.size());\n}\n</code></pre>\n<p>测试结果，2G 的堆大小，如果使用 <code>String#intern()</code>，大概在插入 3000万 数据的时候，开始进入大量的 FullGC。</p>\n<p>而使用自己写的 <code>manualIntern()</code>，大概到 1400万 的时候，就已经不行了。</p>\n<p>没什么结论，如果要说点什么的话，那就是不要自建 String Pool，没必要。</p>\n<h2 id=\"h2-u5C0Fu7ED3\"><a name=\"小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>小结</h2><p>记住有两个 JVM 参数可以设置：-XX:StringTableSize=N、-XX:+PrintStringTableStatistics</p>\n<p>StringTableSize，在 Java 6 中，是 1009；在 Java 7 和 Java 8 中，默认都是 60013，如果有必要请自行扩大这个值。</p>\n<h2 id=\"h2-u53C2u8003u8D44u6599\"><a name=\"参考资料\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考资料</h2><p>Java Performance Tuning Guide: <a href=\"http://java-performance.info/string-intern-in-java-6-7-8/\">String.intern in Java 6, 7 and 8 – string pooling</a></p>\n<p>笨神是真正的大佬：<a href=\"http://lovestblog.cn/blog/2016/11/06/string-intern/\">JVM源码分析之String.intern()导致的YGC不断变长</a></p>\n<p>（全文完）</p>\n', '\n本文将介绍 HotSpot 中的 String Pool，字符串常量池。相对是一篇比较简单的文章，大家花几分钟就看完了。\n\n在 Java 世界中，构造一个 Java 对象是一个相对比较重的活，而且还需要垃圾回收，而缓存池就是为了缓解这个问题的。\n\n我们来看下基础类型的包装类的缓存，Integer 默认缓存 -128 ~ 127 区间的值，Long 和 Short 也是缓存了这个区间的值，Byte 只能表示 -127 ~ 128 范围的值，全部缓存了，Character 缓存了 0 ~ 127 的值。Float 和 Double 没有缓存的意义。\n\n> Integer 可通过设置 java.lang.Integer.IntegerCache.high 扩大缓存区间\n\nString 不是基础类型，但是它也有同样的机制，通过 String Pool 来缓存 String 对象。假设 \"Java\" 这个字符串我们会在应用程序中使用多次，我们肯定不希望在每次使用到的时候，都重新在堆中创建一个新的对象。\n\n> 当然，之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是不可变类\n\n基础类型包装类的缓存池使用一个数组进行缓存，而 String 类型，JVM 内部使用 HashTable 进行缓存，我们知道，HashTable 的结构是一个数组，数组中每个元素是一个链表。和我们平时使用的 HashTable 不同，JVM 内部的这个 HashTable 是不可以动态扩容的。\n\n![1](https://assets.javadoop.com/imgs/20510079/string/1.png)\n\n## 创建和回收\n\n当我们在程序中使用双引号来表示一个字符串时，这个字符串就会进入到 String Pool 中。当然，这里说的是已被加载到 JVM 中的类。\n\n> 这是一个不够严谨的说法，请参见评论区的讨论。\n\n另外，就是 **String#intern()** 方法，这个方法的作用就是：\n\n- 如果字符串未在 Pool 中，那么就往 Pool 中增加一条记录，然后返回 Pool 中的引用。\n- 如果已经在 Pool 中，直接返回 Pool 中的引用。\n\n只要 String Pool 中的 String 对象对于 GC Roots 来说不可达，那么它们就是可以被回收的。\n\n如果 Pool 中对象过多，可能导致 YGC 变长，因为 YGC 的时候，需要扫描 String Pool，可以看看笨神大佬的文章《[JVM源码分析之String.intern()导致的YGC不断变长](http://lovestblog.cn/blog/2016/11/06/string-intern/)》。\n\n## 讨论 String Pool 的实现\n\n**1、首先，我们先考虑 String Pool 的空间问题。**\n\n在 Java 6 中，String Pool 置于 PermGen Space 中，PermGen 有一个问题，那就是它是一个固定大小的区域，虽然我们可以通过 `-XX:MaxPermSize=N` 来设置永久代的空间大小，但是不管我们设置成多少，它终归是固定的。\n\n所以，在 Java 6 中，我们应该尽量小心使用 String.intern() 方法，否则容易导致 OutOfMemoryError。\n\n到了 Java 7，大佬们已经着手去掉 PermGen Space 了，首先，就是将 String Pool 移到了堆中。\n\n把 String Pool 放到堆中，即使堆的大小也是固定的，但是这个时候，对于应用调优工作，只需要调整堆大小就行了。\n\n~~到了 Java 8，PermGen 已经被彻底废弃，出现了堆外内存区域 MetaSpace，String Pool 相应的从堆转移到了 MetaSpace 中。~~\n\n> 在 Java 8 中，String Pool 依然还是在 Heap Space 中。感谢评论区的读者指出错误。大家可以看一下我后面写的关于 MetaSpace 的文章，那篇文章深入分析了 MetaSpace 的构成。\n\n**2、其次，我们再讨论 String Pool 的实现问题。**\n\n前面我们说了 String Pool 使用一个 HashTable 来实现，这个 HashTable **不可以扩容**，也就意味着极有可能出现单个 bucket 中的链表很长，导致性能降低。\n\n在 Java 6 中，这个 HashTable 固定的 bucket 数量是 1009，后来添加了选项（**-XX:StringTableSize=N**）可以配置这个值。到 Java 7（7u40），大佬们提高了这个默认值到 60013，Java 8 依然也是使用这个值，对于绝大部分应用来说，这个值是足够用的。当然，如果你会在代码中大量使用 String#intern()，那么有必要手动设置一下这个值。\n\n> 为什么是 1009，而不是 1000 或者 1024？因为 1009 是质数，有利于达到更好的散列。60013 同理。\n\n JVM 内部的 HashTable 是不扩容的，但是不代表它不 rehash，它会在发现散列不均匀的时候进行 rehash，这里不展开介绍。\n\n**3、观察 String Pool 的使用情况。**\n\nJVM 提供了 `-XX:+PrintStringTableStatistics` 启动参数来帮助我们获取统计数据。\n\n遗憾的是，只有在 JVM 退出的时候，JVM 才会将统计数据打印出来，JVM 没有提供接口给我们实时获取统计数据。\n\n```\nSymbolTable statistics:\nNumber of buckets       :     20011 =    160088 bytes, avg   8.000\nNumber of entries       :     10923 =    262152 bytes, avg  24.000\nNumber of literals      :     10923 =    425192 bytes, avg  38.926\nTotal footprint         :           =    847432 bytes\nAverage bucket size     :     0.546\nVariance of bucket size :     0.545\nStd. dev. of bucket size:     0.738\nMaximum bucket size     :         6\n## 看下面这部分：\nStringTable statistics:\nNumber of buckets       :     60003 =    480024 bytes, avg   8.000\nNumber of entries       :   4000774 =  96018576 bytes, avg  24.000\nNumber of literals      :   4000774 = 1055252184 bytes, avg 263.762\nTotal footprint         :           = 1151750784 bytes\nAverage bucket size     :    66.676\nVariance of bucket size :    19.843\nStd. dev. of bucket size:     4.455\nMaximum bucket size     :        84\n\n```\n\n统计数据中包含了 buckets 的数量，总的 String 对象的数量，占用的总空间，单个 bucket 的链表平均长度和最大长度等。\n\n上面的数据是在 Java 8 的环境中打印出来的，Java 7 的信息稍微少一些，主要是没有 footprint 的数据：\n\n```\nStringTable statistics:\nNumber of buckets       :   60003\nAverage bucket size     :      67\nVariance of bucket size :      20\nStd. dev. of bucket size:       4\nMaximum bucket size     :      84\n```\n\n## 测试 String Pool 的性能\n\n接下来，我们来跑个测试，测试下 String Pool 的性能问题，并讨论 -XX:StringTableSize=N 参数的作用。\n\n我们将使用 `String#intern()` 往字符串常量池中添加 **400万** 个不同的长字符串。\n\n```java\npackage com.javadoop;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.WeakHashMap;\n\npublic class StringTest {\n\n    public static void main(String[] args) {\n        test(4000000);\n    }\n\n    private static void test(int cnt) {\n        final List<String> lst = new ArrayList<String>(1024);\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < cnt; ++i) {\n            final String str = \"Very very very very very very very very very very very very very very \" +\n                    \"very long string: \" + i;\n            lst.add(str.intern());\n\n            if (i % 200000 == 0) {\n                System.out.println(i + 200000 + \"; time = \" + (System.currentTimeMillis() - start) / 1000.0 + \" sec\");\n                start = System.currentTimeMillis();\n            }\n        }\n        System.out.println(\"Total length = \" + lst.size());\n    }\n}\n```\n\n我们每插入 20万 条数据，输出一次耗时。\n\n```shell\n# 编译\njavac -d . StringTest.java\n# 使用默认 table size (60013) 运行一次\njava -Xms2g -Xmx2g com.javadoop.StringTest\n# 设置 table size 为 400031，再运行一次\njava -Xms2g -Xmx2g -XX:StringTableSize=400031 com.javadoop.StringTest\n```\n\n![2](https://assets.javadoop.com/imgs/20510079/string/2.png)\n\n从左右两部分数据可以很直观看出来，插入的性能主要取决于链表的平均长度。当链表平均长度为 10 的时候，我们看到性能是几乎没有任何损失的。\n\n还是那句话，根据自己的实际情况，考虑是否要设置 -XX:StringTableSize=N，还是使用默认值。\n\n## 讨论自建 String Pool\n\n这一节我们来看下自己使用 HashMap 来实现 String Pool。\n\n这里我们需要使用 WeakReference：\n\n```java\nprivate static final WeakHashMap<String, WeakReference<String>> pool\n            = new WeakHashMap<String, WeakReference<String>>(1024);\n\nprivate static String manualIntern(final String str) {\n    final WeakReference<String> cached = pool.get(str);\n    if (cached != null) {\n        final String value = cached.get();\n        if (value != null) {\n            return value;\n        }\n    }\n    pool.put(str, new WeakReference<String>(str));\n    return str;\n}\n```\n\n我们使用 1000 \\* 1000 \\* 1000 作为入参 cnt 的值进行测试，分别测试 [1] 和 [2]：\n\n```java\nprivate static void test(int cnt) {\n    final List<String> lst = new ArrayList<String>(1024);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < cnt; ++i) {\n      	// [1]\n        lst.add(String.valueOf(i).intern());\n        // [2]\n        // lst.add(manualIntern(String.valueOf(i)));\n      \n        if (i % 200000 == 0) {\n            System.out.println(i + 200000 + \"; time = \" + (System.currentTimeMillis() - start) / 1000.0 + \" sec\");\n            start = System.currentTimeMillis();\n        }\n    }\n    System.out.println(\"Total length = \" + lst.size());\n}\n```\n\n测试结果，2G 的堆大小，如果使用 `String#intern()`，大概在插入 3000万 数据的时候，开始进入大量的 FullGC。\n\n而使用自己写的 `manualIntern()`，大概到 1400万 的时候，就已经不行了。\n\n没什么结论，如果要说点什么的话，那就是不要自建 String Pool，没必要。\n\n## 小结\n\n记住有两个 JVM 参数可以设置：-XX:StringTableSize=N、-XX:+PrintStringTableStatistics\n\nStringTableSize，在 Java 6 中，是 1009；在 Java 7 和 Java 8 中，默认都是 60013，如果有必要请自行扩大这个值。\n\n## 参考资料\n\nJava Performance Tuning Guide: [String.intern in Java 6, 7 and 8 – string pooling](http://java-performance.info/string-intern-in-java-6-7-8/)\n\n笨神是真正的大佬：[JVM源码分析之String.intern()导致的YGC不断变长](http://lovestblog.cn/blog/2016/11/06/string-intern/)\n\n（全文完）\n', '1', '0', '0', '1', '1', '', '43', 'admin', '2020-04-19 21:39:21', 'admin', '2020-04-19 21:39:21');
INSERT INTO `biz_article` VALUES ('9', '1', '1', '礼薄设计', '礼薄表', '', '1', '<h1 id=\"h1-u793Cu8584\"><a name=\"礼薄\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>礼薄</h1><p>x ☺下</p>\n<blockquote>\n<p>礼薄表(封面)  </p>\n</blockquote>\n<pre><code>姓名、名称、描述、时间\n\n例如：王川东\n      百年好合，喜结连理 \n      描述具体\n</code></pre><blockquote>\n<p>人情表  </p>\n</blockquote>\n<pre><code>姓名、礼金(大小写)、备注、时间\n\n例如：王川东\n      500(伍佰元整)\n      男方宾客\n</code></pre><blockquote>\n<p>设置表  </p>\n</blockquote>\n<pre><code>背景图片(礼薄/人情)、字体、颜色、\n</code></pre><blockquote>\n<p>礼金汇总  </p>\n</blockquote>\n<p>汇总界面可查看所有人情礼金的汇总数据情况、界面中将显示礼金总额、礼金平均额、礼金最大额、礼金最小额</p>\n<h2 id=\"h2-u8BE6u7EC6u8BF4u660E\"><a name=\"详细说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>详细说明</h2><ul>\n<li><p>添加礼薄，可写备注(例如：<font color=\"red\">百年好合，喜结连理</font> )、可设置封面、字体、颜色等。</p>\n</li><li><p>添加人情，如果已存在，将提示是否更改。</p>\n</li><li><p>注册后通过设置界面，可实现个性化显示，例如将封面设置成婚纱照等等。</p>\n</li></ul>\n', '# 礼薄\nx ☺下\n> 礼薄表(封面)  \n\n	姓名、名称、描述、时间\n	\n	例如：王川东\n	      百年好合，喜结连理 \n	      描述具体\n> 人情表  \n\n	姓名、礼金(大小写)、备注、时间\n	\n	例如：王川东\n		  500(伍佰元整)\n		  男方宾客\n		  \n> 设置表  \n\n	背景图片(礼薄/人情)、字体、颜色、\n	\n> 礼金汇总  \n\n汇总界面可查看所有人情礼金的汇总数据情况、界面中将显示礼金总额、礼金平均额、礼金最大额、礼金最小额\n\n## 详细说明\n\n- 添加礼薄，可写备注(例如：<font color=\'red\'>百年好合，喜结连理</font> )、可设置封面、字体、颜色等。\n\n- 添加人情，如果已存在，将提示是否更改。\n\n- 注册后通过设置界面，可实现个性化显示，例如将封面设置成婚纱照等等。', '0', '0', '1', '1', '1', '', '2', 'admin', '2020-04-20 22:34:31', 'admin', '2020-04-20 22:34:31');
INSERT INTO `biz_article` VALUES ('10', '1', '1', 'md', 'markdown ', '', '1', '<h1 id=\"h1-u8FD9u662Fu4E00u7EA7u6807u9898\"><a name=\"这是一级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是一级标题</h1><h2 id=\"h2-u8FD9u662Fu4E8Cu7EA7u6807u9898\"><a name=\"这是二级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是二级标题</h2><h3 id=\"h3-u8FD9u662Fu4E09u7EA7u6807u9898\"><a name=\"这是三级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是三级标题</h3><h4 id=\"h4-u8FD9u662Fu56DBu7EA7u6807u9898\"><a name=\"这是四级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是四级标题</h4><h5 id=\"h5-u8FD9u662Fu4E94u7EA7u6807u9898\"><a name=\"这是五级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是五级标题</h5><h6 id=\"h6-u8FD9u662Fu516Du7EA7u6807u9898\"><a name=\"这是六级标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这是六级标题</h6><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>这是引用的内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>当然，之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是不可变类</p>\n</blockquote>\n<h2 id=\"h2--\"><a name=\"—-\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>—-</h2><hr>\n<hr>\n<p><a href=\"http://jianshu.com\">简书</a><br><a href=\"http://baidu.com\">百度</a></p>\n<ul>\n<li>列表内容</li></ul>\n<ul>\n<li>列表内容</li></ul>\n<ul>\n<li>列表内容</li></ul>\n<ol>\n<li>列表内容</li><li>列表内容</li><li>列表内容</li></ol>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th style=\"text-align:center\">技能</th>\n<th style=\"text-align:right\">排行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>刘备</td>\n<td style=\"text-align:center\">哭</td>\n<td style=\"text-align:right\">大哥</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td style=\"text-align:center\">打</td>\n<td style=\"text-align:right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td style=\"text-align:center\">骂</td>\n<td style=\"text-align:right\">三弟</td>\n</tr>\n</tbody>\n</table>\n<p><code>create database hero;</code></p>\n<pre><code>    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2018/10/7/1664c39eb393e946\" alt=\"image.png\">\n', '# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n\n\n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n\n> 当然，之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是不可变类\n\n---\n----\n***\n*****\n\n[简书](http://jianshu.com)  \n[百度](http://baidu.com)\n\n- 列表内容\n+ 列表内容\n* 列表内容\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥\n关羽|打|二哥\n张飞|骂|三弟\n\n`create database hero;`\n\n```\n    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n```\n\n![image.png](https://user-gold-cdn.xitu.io/2018/10/7/1664c39eb393e946)', '1', '0', '1', '1', '1', '', '6', 'admin', '2020-04-21 21:42:53', 'admin', '2020-04-21 21:42:53');
INSERT INTO `biz_article` VALUES ('11', '1', '1', '我的心态蹦了', 'MarkDown 实时展示', '/profile/upload/2020/04/22/0.jpg', '1', '<h1 id=\"这是一级标题\">这是一级标题</h1>\n<h2 id=\"这是二级标题\">这是二级标题</h2>\n<h3 id=\"这是三级标题\">这是三级标题</h3>\n<h4 id=\"这是四级标题\">这是四级标题</h4>\n<h5 id=\"这是五级标题\">这是五级标题</h5>\n<h6 id=\"这是六级标题\">这是六级标题</h6>\n<p><strong>这是加粗的文字</strong>\n<em>这是倾斜的文字<em>`\n<em>**这是斜体加粗的文字</em></em></em>\n<del>这是加删除线的文字</del></p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>这是引用的内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<hr>\n<hr>\n<hr>\n<p><a href=\"http://jianshu.com\">简书</a><br><a href=\"http://baidu.com\">百度</a></p>\n<ul>\n<li>列表内容</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ul>\n<ol>\n<li>列表内容</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th align=\"center\">技能</th>\n<th align=\"right\">排行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>刘备</td>\n<td align=\"center\">哭</td>\n<td align=\"right\">大哥</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td align=\"center\">打</td>\n<td align=\"right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td align=\"center\">骂</td>\n<td align=\"right\">三弟</td>\n</tr>\n</tbody></table>\n<p><code>create database hero;</code></p>\n<pre><code>    function fun(){\n         echo &quot;这是一句非常牛逼的代码&quot;;\n    }\n    fun();</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2018/10/7/1664c39eb393e946\" alt=\"image.png\"></p>\n<blockquote>\n<p>实时</p>\n</blockquote>\n', '# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n\n\n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n\n---\n----\n***\n*****\n\n[简书](http://jianshu.com)  \n[百度](http://baidu.com)\n\n- 列表内容\n+ 列表内容\n* 列表内容\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥\n关羽|打|二哥\n张飞|骂|三弟\n\n`create database hero;`\n\n```\n    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n```\n\n![image.png](https://user-gold-cdn.xitu.io/2018/10/7/1664c39eb393e946)\n\n> 实时', '1', '0', '1', '1', '1', '', '5', 'admin', '2020-04-22 23:01:48', 'admin', '2020-04-22 23:03:21');
INSERT INTO `biz_article` VALUES ('12', '1', '3', '解读 java 并发队列 BlockingQueue', 'ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。\n\nLinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。\n\nSynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。\n\nPriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。', '', '1', '<h2 id=\"blockingqueue\">BlockingQueue</h2>\n<p>BlockingQueue 是一个先进先出的队列（Queue），不接受 null 值的插入，BlockingQueue的实现都是线程安全的，但是批量的集合操作如 addAll, containsAll, retainAll 和 removeAll  不一定是原子操作。</p>\n<blockquote>\n<p>BlockingQueue :  重点关注 put(e) 和 take() 这两个方法，因为这两个方法是带阻塞的。</p>\n</blockquote>\n<h2 id=\"blockingqueue-实现之-arrayblockingqueue\">BlockingQueue 实现之 ArrayBlockingQueue</h2>\n<p>ArrayBlockingQueue 是有界队列实现类，底层采用数组实现。并发控制采用可重入锁来控制。<br>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。\nArrayBlockingQueue 类有哪些属性</p>\n<pre><code>// 用于存放元素的数组\nfinal Object[] items;\n// 下一次读取操作的位置\nint takeIndex;\n// 下一次写入操作的位置\nint putIndex;\n// 队列中的元素数量\nint count;\n\n// 以下几个就是控制并发用的同步器\nfinal ReentrantLock lock;\nprivate final Condition notEmpty;\nprivate final Condition notFull;</code></pre><h2 id=\"blockingqueue-实现之-linkedblockingqueue\">BlockingQueue 实现之 LinkedBlockingQueue</h2>\n<p>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。\n读操作是排好队的，写操作也是排好队的，唯一的并发问题在于一个写操作和一个读操作同时进行，只要控制好这个就可以了。\nLinkedBlockingQueue 类有哪些属性</p>\n<pre><code>// 队列容量\nprivate final int capacity;\n\n// 队列中的元素数量\nprivate final AtomicInteger count = new AtomicInteger(0);\n\n// 队头\nprivate transient Node&lt;E&gt; head;\n\n// 队尾\nprivate transient Node&lt;E&gt; last;\n\n// take, poll, peek 等读操作的方法需要获取到这个锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n\n// 如果读操作的时候队列是空的，那么等待 notEmpty 条件\nprivate final Condition notEmpty = takeLock.newCondition();\n\n// put, offer 等写操作的方法需要获取到这个锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n\n// 如果写操作的时候队列是满的，那么等待 notFull 条件\nprivate final Condition notFull = putLock.newCondition();</code></pre><p>初始化</p>\n<pre><code>public LinkedBlockingQueue(int capacity) {\n    if (capacity &lt;= 0) throw new IllegalArgumentException();\n    this.capacity = capacity;\n    last = head = new Node&lt;E&gt;(null);\n}</code></pre><p>这里会初始化一个空的头结点，那么第一个元素入队的时候，队列中就会有两个元素。读取元素时，也总是获取头节点后面的一个节点。count 的计数值不包括这个头节点。\n我们来看下 put 方法是怎么将元素插入到队尾的</p>\n<pre><code>public void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    // 如果你纠结这里为什么是 -1，可以看看 offer 方法。这就是个标识成功、失败的标志而已。\n    int c = -1;\n    Node&lt;E&gt; node = new Node(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    // 必须要获取到 putLock 才可以进行插入操作\n    putLock.lockInterruptibly();\n    try {\n        // 如果队列满，等待 notFull 的条件满足。\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        // 入队\n        enqueue(node);\n        // count 原子加 1，c 还是加 1 前的值\n        c = count.getAndIncrement();\n        // 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。\n        // 哪些线程会等待在 notFull 这个 Condition 上呢？\n        if (c + 1 &lt; capacity)\n            notFull.signal();\n    } finally {\n        // 入队后，释放掉 putLock\n        putLock.unlock();\n    }\n    // 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），\n    // 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作\n    if (c == 0)\n        signalNotEmpty();\n}\n\n// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素\n// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作\nprivate void enqueue(Node&lt;E&gt; node) {\n    // assert putLock.isHeldByCurrentThread();\n    // assert last.next == null;\n    last = last.next = node;\n}\n\n// 元素入队后，如果需要，调用这个方法唤醒读线程来读\nprivate void signalNotEmpty() {\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lock();\n    try {\n        notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n}</code></pre><p>我们再看看 take 方法</p>\n<pre><code>public E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    // 首先，需要获取到 takeLock 才能进行出队操作\n    takeLock.lockInterruptibly();\n    try {\n        // 如果队列为空，等待 notEmpty 这个条件满足再继续执行\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        // 出队\n        x = dequeue();\n        // count 进行原子减 1\n        c = count.getAndDecrement();\n        // 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程\n        if (c &gt; 1)\n            notEmpty.signal();\n    } finally {\n        // 出队后释放掉 takeLock\n        takeLock.unlock();\n    }\n    // 如果 c == capacity，那么说明在这个 take 方法发生的时候，队列是满的\n    // 既然出队了一个，那么意味着队列不满了，唤醒写线程去写\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n// 取队头，出队\nprivate E dequeue() {\n    // assert takeLock.isHeldByCurrentThread();\n    // assert head.item == null;\n    // 之前说了，头结点是空的\n    Node&lt;E&gt; h = head;\n    Node&lt;E&gt; first = h.next;\n    h.next = h; // help GC\n    // 设置这个为新的头结点\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n// 元素出队后，如果需要，调用这个方法唤醒写线程来写\nprivate void signalNotFull() {\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock();\n    try {\n        notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n}</code></pre><h2 id=\"blockingqueue-实现之-synchronousqueue\">BlockingQueue 实现之 SynchronousQueue</h2>\n<p>它是一个特殊的队列，它的名字其实就蕴含了它的特征 - - 同步的队列。为什么说是同步的呢？这里说的并不是多线程的并发问题，而是因为当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作。这里的 Synchronous 指的就是读线程和写线程需要同步，一个读线程匹配一个写线程。</p>\n<p>虽然上面我说了队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</p>\n<p>你不能在 SynchronousQueue 中使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。SynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。当然，这个类也是不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。</p>\n<h2 id=\"blockingqueue-实现之-priorityblockingqueue\">BlockingQueue 实现之 PriorityBlockingQueue</h2>\n<p>带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>\n<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>\n<p>PriorityBlockingQueue 属性说明</p>\n<pre><code>// 构造方法中，如果不指定大小的话，默认大小为 11\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n// 数组的最大容量\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n// 这个就是存放数据的数组\nprivate transient Object[] queue;\n\n// 队列当前大小\nprivate transient int size;\n\n// 大小比较器，如果按照自然序排序，那么此属性可设置为 null\nprivate transient Comparator&lt;? super E&gt; comparator;\n\n// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁\nprivate final ReentrantLock lock;\n\n// 这个很好理解，其实例由上面的 lock 属性创建\nprivate final Condition notEmpty;\n\n// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作\n// 其使用 CAS 操作\nprivate transient volatile int allocationSpinLock;\n\n// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化\nprivate PriorityQueue q;</code></pre><p>PriorityBlockingQueue 使用了基于数组的二叉堆来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。</p>\n<p>二叉堆：一颗完全二叉树，它非常适合用数组进行存储，对于数组中的元素 a[i]，其左子节点为 a[2<em>i+1]，其右子节点为 a[2</em>i + 2]，其父节点为 a[(i-1)/2]，其堆序性质为，每个节点的值都小于其左右子节点的值。二叉堆中最小的值就是根节点，但是删除根节点是比较麻烦的，因为需要调整树。</p>\n<p>扩容实现</p>\n<pre><code>private void tryGrow(Object[] array, int oldCap) {\n    // 这边做了释放锁的操作\n    lock.unlock(); // must release and then re-acquire main lock\n    Object[] newArray = null;\n    // 用 CAS 操作将 allocationSpinLock 由 0 变为 1，也算是获取锁\n    if (allocationSpinLock == 0 &amp;&amp;\n        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,\n                                 0, 1)) {\n        try {\n            // 如果节点个数小于 64，那么增加的 oldCap + 2 的容量\n            // 如果节点数大于等于 64，那么增加 oldCap 的一半\n            // 所以节点数较小时，增长得快一些\n            int newCap = oldCap + ((oldCap &lt; 64) ?\n                                   (oldCap + 2) :\n                                   (oldCap &gt;&gt; 1));\n            // 这里有可能溢出\n            if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow\n                int minCap = oldCap + 1;\n                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)\n                    throw new OutOfMemoryError();\n                newCap = MAX_ARRAY_SIZE;\n            }\n            // 如果 queue != array，那么说明有其他线程给 queue 分配了其他的空间\n            if (newCap &gt; oldCap &amp;&amp; queue == array)\n                // 分配一个新的大数组\n                newArray = new Object[newCap];\n        } finally {\n            // 重置，也就是释放锁\n            allocationSpinLock = 0;\n        }\n    }\n    // 如果有其他的线程也在做扩容的操作\n    if (newArray == null) // back off if another thread is allocating\n        Thread.yield();\n    // 重新获取锁\n    lock.lock();\n    // 将原来数组中的元素复制到新分配的大数组中\n    if (newArray != null &amp;&amp; queue == array) {\n        queue = newArray;\n        System.arraycopy(array, 0, newArray, 0, oldCap);\n    }\n}</code></pre><p>扩容方法对并发的控制也非常的巧妙，释放了原来的独占锁 lock，这样的话，扩容操作和读操作可以同时进行，提高吞吐量。</p>\n<p>写操作 put 方法和读操作 take 方法</p>\n<pre><code>public void put(E e) {\n    // 直接调用 offer 方法，因为前面我们也说了，在这里，put 方法不会阻塞\n    offer(e); \n}\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    // 首先获取到独占锁\n    lock.lock();\n    int n, cap;\n    Object[] array;\n    // 如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了\n    while ((n = size) &gt;= (cap = (array = queue).length))\n        tryGrow(array, cap);\n    try {\n        Comparator&lt;? super E&gt; cmp = comparator;\n        // 节点添加到二叉堆中\n        if (cmp == null)\n            siftUpComparable(n, e, array);\n        else\n            siftUpUsingComparator(n, e, array, cmp);\n        // 更新 size\n        size = n + 1;\n        // 唤醒等待的读线程\n        notEmpty.signal();\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}</code></pre><p>对于二叉堆而言，插入一个节点是简单的，插入的节点如果比父节点小，交换它们，然后继续和父节点比较。</p>\n<pre><code>// 这个方法就是将数据 x 插入到数组 array 的位置 k 处，然后再调整树\nprivate static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) {\n    Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;\n    while (k &gt; 0) {\n        // 二叉堆中 a[k] 节点的父节点位置\n        int parent = (k - 1) &gt;&gt;&gt; 1;\n        Object e = array[parent];\n        if (key.compareTo((T) e) &gt;= 0)\n            break;\n        array[k] = e;\n        k = parent;\n    }\n    array[k] = key;\n}</code></pre><p> take 方法</p>\n<pre><code>public E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    // 独占锁\n    lock.lockInterruptibly();\n    E result;\n    try {\n        // dequeue 出队\n        while ( (result = dequeue()) == null)\n            notEmpty.await();\n    } finally {\n        lock.unlock();\n    }\n    return result;\n}</code></pre><pre><code>private E dequeue() {\n    int n = size - 1;\n    if (n &lt; 0)\n        return null;\n    else {\n        Object[] array = queue;\n        // 队头，用于返回\n        E result = (E) array[0];\n        // 队尾元素先取出\n        E x = (E) array[n];\n        // 队尾置空\n        array[n] = null;\n        Comparator&lt;? super E&gt; cmp = comparator;\n        if (cmp == null)\n            siftDownComparable(0, x, array, n);\n        else\n            siftDownUsingComparator(0, x, array, n, cmp);\n        size = n;\n        return result;\n    }\n}</code></pre><p>dequeue 方法返回队头，并调整二叉堆的树，调用这个方法必须先获取独占锁。</p>\n<p>废话不多说，出队是非常简单的，因为队头就是最小的元素，对应的是数组的第一个元素。难点是队头出队后，需要调整树。</p>\n<pre><code>private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,\n                                           int n) {\n    if (n &gt; 0) {\n        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;\n        // 这里得到的 half 肯定是非叶节点\n        // a[n] 是最后一个元素，其父节点是 a[(n-1)/2]。所以 n &gt;&gt;&gt; 1 代表的节点肯定不是叶子节点\n        // 下面，我们结合图来一行行分析，这样比较直观简单\n        // 此时 k 为 0, x 为 17，n 为 9\n        int half = n &gt;&gt;&gt; 1; // 得到 half = 4\n        while (k &lt; half) {\n            // 先取左子节点\n            int child = (k &lt;&lt; 1) + 1; // 得到 child = 1\n            Object c = array[child];  // c = 12\n            int right = child + 1;  // right = 2\n            // 如果右子节点存在，而且比左子节点小\n            // 此时 array[right] = 20，所以条件不满足\n            if (right &lt; n &amp;&amp;\n                ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)\n                c = array[child = right];\n            // key = 17, c = 12，所以条件不满足\n            if (key.compareTo((T) c) &lt;= 0)\n                break;\n            // 把 12 填充到根节点\n            array[k] = c;\n            // k 赋值后为 1\n            k = child;\n            // 一轮过后，我们发现，12 左边的子树和刚刚的差不多，都是缺少根节点，接下来处理就简单了\n        }\n        array[k] = key;\n    }\n}</code></pre><h2 id=\"总结\">总结</h2>\n<p>ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</p>\n<p>LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</p>\n<p>SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</p>\n<p>PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</p>\n', '## BlockingQueue\nBlockingQueue 是一个先进先出的队列（Queue），不接受 null 值的插入，BlockingQueue的实现都是线程安全的，但是批量的集合操作如 addAll, containsAll, retainAll 和 removeAll  不一定是原子操作。\n\n> BlockingQueue :  重点关注 put(e) 和 take() 这两个方法，因为这两个方法是带阻塞的。\n\n\n## BlockingQueue 实现之 ArrayBlockingQueue\nArrayBlockingQueue 是有界队列实现类，底层采用数组实现。并发控制采用可重入锁来控制。  \nArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。\nArrayBlockingQueue 类有哪些属性\n```\n// 用于存放元素的数组\nfinal Object[] items;\n// 下一次读取操作的位置\nint takeIndex;\n// 下一次写入操作的位置\nint putIndex;\n// 队列中的元素数量\nint count;\n\n// 以下几个就是控制并发用的同步器\nfinal ReentrantLock lock;\nprivate final Condition notEmpty;\nprivate final Condition notFull;\n```\n\n\n## BlockingQueue 实现之 LinkedBlockingQueue\n底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。\n读操作是排好队的，写操作也是排好队的，唯一的并发问题在于一个写操作和一个读操作同时进行，只要控制好这个就可以了。\nLinkedBlockingQueue 类有哪些属性\n```\n// 队列容量\nprivate final int capacity;\n\n// 队列中的元素数量\nprivate final AtomicInteger count = new AtomicInteger(0);\n\n// 队头\nprivate transient Node<E> head;\n\n// 队尾\nprivate transient Node<E> last;\n\n// take, poll, peek 等读操作的方法需要获取到这个锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n\n// 如果读操作的时候队列是空的，那么等待 notEmpty 条件\nprivate final Condition notEmpty = takeLock.newCondition();\n\n// put, offer 等写操作的方法需要获取到这个锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n\n// 如果写操作的时候队列是满的，那么等待 notFull 条件\nprivate final Condition notFull = putLock.newCondition();\n```\n\n初始化\n```\npublic LinkedBlockingQueue(int capacity) {\n    if (capacity <= 0) throw new IllegalArgumentException();\n    this.capacity = capacity;\n    last = head = new Node<E>(null);\n}\n```\n\n这里会初始化一个空的头结点，那么第一个元素入队的时候，队列中就会有两个元素。读取元素时，也总是获取头节点后面的一个节点。count 的计数值不包括这个头节点。\n我们来看下 put 方法是怎么将元素插入到队尾的\n```\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    // 如果你纠结这里为什么是 -1，可以看看 offer 方法。这就是个标识成功、失败的标志而已。\n    int c = -1;\n    Node<E> node = new Node(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    // 必须要获取到 putLock 才可以进行插入操作\n    putLock.lockInterruptibly();\n    try {\n        // 如果队列满，等待 notFull 的条件满足。\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        // 入队\n        enqueue(node);\n        // count 原子加 1，c 还是加 1 前的值\n        c = count.getAndIncrement();\n        // 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。\n        // 哪些线程会等待在 notFull 这个 Condition 上呢？\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        // 入队后，释放掉 putLock\n        putLock.unlock();\n    }\n    // 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），\n    // 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作\n    if (c == 0)\n        signalNotEmpty();\n}\n\n// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素\n// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作\nprivate void enqueue(Node<E> node) {\n    // assert putLock.isHeldByCurrentThread();\n    // assert last.next == null;\n    last = last.next = node;\n}\n\n// 元素入队后，如果需要，调用这个方法唤醒读线程来读\nprivate void signalNotEmpty() {\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lock();\n    try {\n        notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n}\n```\n我们再看看 take 方法\n```\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    // 首先，需要获取到 takeLock 才能进行出队操作\n    takeLock.lockInterruptibly();\n    try {\n        // 如果队列为空，等待 notEmpty 这个条件满足再继续执行\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        // 出队\n        x = dequeue();\n        // count 进行原子减 1\n        c = count.getAndDecrement();\n        // 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程\n        if (c > 1)\n            notEmpty.signal();\n    } finally {\n        // 出队后释放掉 takeLock\n        takeLock.unlock();\n    }\n    // 如果 c == capacity，那么说明在这个 take 方法发生的时候，队列是满的\n    // 既然出队了一个，那么意味着队列不满了，唤醒写线程去写\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n// 取队头，出队\nprivate E dequeue() {\n    // assert takeLock.isHeldByCurrentThread();\n    // assert head.item == null;\n    // 之前说了，头结点是空的\n    Node<E> h = head;\n    Node<E> first = h.next;\n    h.next = h; // help GC\n    // 设置这个为新的头结点\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n// 元素出队后，如果需要，调用这个方法唤醒写线程来写\nprivate void signalNotFull() {\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock();\n    try {\n        notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n}\n```\n\n\n## BlockingQueue 实现之 SynchronousQueue\n它是一个特殊的队列，它的名字其实就蕴含了它的特征 - - 同步的队列。为什么说是同步的呢？这里说的并不是多线程的并发问题，而是因为当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作。这里的 Synchronous 指的就是读线程和写线程需要同步，一个读线程匹配一个写线程。\n\n虽然上面我说了队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。\n\n你不能在 SynchronousQueue 中使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。SynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。当然，这个类也是不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。\n\n## BlockingQueue 实现之 PriorityBlockingQueue\n带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。\n\n简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\n\nPriorityBlockingQueue 属性说明\n```\n// 构造方法中，如果不指定大小的话，默认大小为 11\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n// 数组的最大容量\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n// 这个就是存放数据的数组\nprivate transient Object[] queue;\n\n// 队列当前大小\nprivate transient int size;\n\n// 大小比较器，如果按照自然序排序，那么此属性可设置为 null\nprivate transient Comparator<? super E> comparator;\n\n// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁\nprivate final ReentrantLock lock;\n\n// 这个很好理解，其实例由上面的 lock 属性创建\nprivate final Condition notEmpty;\n\n// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作\n// 其使用 CAS 操作\nprivate transient volatile int allocationSpinLock;\n\n// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化\nprivate PriorityQueue q;\n```\n\nPriorityBlockingQueue 使用了基于数组的二叉堆来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。\n\n二叉堆：一颗完全二叉树，它非常适合用数组进行存储，对于数组中的元素 a[i]，其左子节点为 a[2*i+1]，其右子节点为 a[2*i + 2]，其父节点为 a[(i-1)/2]，其堆序性质为，每个节点的值都小于其左右子节点的值。二叉堆中最小的值就是根节点，但是删除根节点是比较麻烦的，因为需要调整树。\n\n扩容实现\n```\nprivate void tryGrow(Object[] array, int oldCap) {\n    // 这边做了释放锁的操作\n    lock.unlock(); // must release and then re-acquire main lock\n    Object[] newArray = null;\n    // 用 CAS 操作将 allocationSpinLock 由 0 变为 1，也算是获取锁\n    if (allocationSpinLock == 0 &&\n        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,\n                                 0, 1)) {\n        try {\n            // 如果节点个数小于 64，那么增加的 oldCap + 2 的容量\n            // 如果节点数大于等于 64，那么增加 oldCap 的一半\n            // 所以节点数较小时，增长得快一些\n            int newCap = oldCap + ((oldCap < 64) ?\n                                   (oldCap + 2) :\n                                   (oldCap >> 1));\n            // 这里有可能溢出\n            if (newCap - MAX_ARRAY_SIZE > 0) {    // possible overflow\n                int minCap = oldCap + 1;\n                if (minCap < 0 || minCap > MAX_ARRAY_SIZE)\n                    throw new OutOfMemoryError();\n                newCap = MAX_ARRAY_SIZE;\n            }\n            // 如果 queue != array，那么说明有其他线程给 queue 分配了其他的空间\n            if (newCap > oldCap && queue == array)\n                // 分配一个新的大数组\n                newArray = new Object[newCap];\n        } finally {\n            // 重置，也就是释放锁\n            allocationSpinLock = 0;\n        }\n    }\n    // 如果有其他的线程也在做扩容的操作\n    if (newArray == null) // back off if another thread is allocating\n        Thread.yield();\n    // 重新获取锁\n    lock.lock();\n    // 将原来数组中的元素复制到新分配的大数组中\n    if (newArray != null && queue == array) {\n        queue = newArray;\n        System.arraycopy(array, 0, newArray, 0, oldCap);\n    }\n}\n```\n\n扩容方法对并发的控制也非常的巧妙，释放了原来的独占锁 lock，这样的话，扩容操作和读操作可以同时进行，提高吞吐量。\n\n写操作 put 方法和读操作 take 方法\n```\npublic void put(E e) {\n    // 直接调用 offer 方法，因为前面我们也说了，在这里，put 方法不会阻塞\n    offer(e); \n}\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    // 首先获取到独占锁\n    lock.lock();\n    int n, cap;\n    Object[] array;\n    // 如果当前队列中的元素个数 >= 数组的大小，那么需要扩容了\n    while ((n = size) >= (cap = (array = queue).length))\n        tryGrow(array, cap);\n    try {\n        Comparator<? super E> cmp = comparator;\n        // 节点添加到二叉堆中\n        if (cmp == null)\n            siftUpComparable(n, e, array);\n        else\n            siftUpUsingComparator(n, e, array, cmp);\n        // 更新 size\n        size = n + 1;\n        // 唤醒等待的读线程\n        notEmpty.signal();\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}\n```\n对于二叉堆而言，插入一个节点是简单的，插入的节点如果比父节点小，交换它们，然后继续和父节点比较。\n\n\n```\n// 这个方法就是将数据 x 插入到数组 array 的位置 k 处，然后再调整树\nprivate static <T> void siftUpComparable(int k, T x, Object[] array) {\n    Comparable<? super T> key = (Comparable<? super T>) x;\n    while (k > 0) {\n        // 二叉堆中 a[k] 节点的父节点位置\n        int parent = (k - 1) >>> 1;\n        Object e = array[parent];\n        if (key.compareTo((T) e) >= 0)\n            break;\n        array[k] = e;\n        k = parent;\n    }\n    array[k] = key;\n}\n```\n\n take 方法\n \n```\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    // 独占锁\n    lock.lockInterruptibly();\n    E result;\n    try {\n        // dequeue 出队\n        while ( (result = dequeue()) == null)\n            notEmpty.await();\n    } finally {\n        lock.unlock();\n    }\n    return result;\n}\n```\n\n```\nprivate E dequeue() {\n    int n = size - 1;\n    if (n < 0)\n        return null;\n    else {\n        Object[] array = queue;\n        // 队头，用于返回\n        E result = (E) array[0];\n        // 队尾元素先取出\n        E x = (E) array[n];\n        // 队尾置空\n        array[n] = null;\n        Comparator<? super E> cmp = comparator;\n        if (cmp == null)\n            siftDownComparable(0, x, array, n);\n        else\n            siftDownUsingComparator(0, x, array, n, cmp);\n        size = n;\n        return result;\n    }\n}\n```\n\ndequeue 方法返回队头，并调整二叉堆的树，调用这个方法必须先获取独占锁。\n\n废话不多说，出队是非常简单的，因为队头就是最小的元素，对应的是数组的第一个元素。难点是队头出队后，需要调整树。\n\n```\nprivate static <T> void siftDownComparable(int k, T x, Object[] array,\n                                           int n) {\n    if (n > 0) {\n        Comparable<? super T> key = (Comparable<? super T>)x;\n        // 这里得到的 half 肯定是非叶节点\n        // a[n] 是最后一个元素，其父节点是 a[(n-1)/2]。所以 n >>> 1 代表的节点肯定不是叶子节点\n        // 下面，我们结合图来一行行分析，这样比较直观简单\n        // 此时 k 为 0, x 为 17，n 为 9\n        int half = n >>> 1; // 得到 half = 4\n        while (k < half) {\n            // 先取左子节点\n            int child = (k << 1) + 1; // 得到 child = 1\n            Object c = array[child];  // c = 12\n            int right = child + 1;  // right = 2\n            // 如果右子节点存在，而且比左子节点小\n            // 此时 array[right] = 20，所以条件不满足\n            if (right < n &&\n                ((Comparable<? super T>) c).compareTo((T) array[right]) > 0)\n                c = array[child = right];\n            // key = 17, c = 12，所以条件不满足\n            if (key.compareTo((T) c) <= 0)\n                break;\n            // 把 12 填充到根节点\n            array[k] = c;\n            // k 赋值后为 1\n            k = child;\n            // 一轮过后，我们发现，12 左边的子树和刚刚的差不多，都是缺少根节点，接下来处理就简单了\n        }\n        array[k] = key;\n    }\n}\n```\n\n## 总结\n\nArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。\n\nLinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。\n\nSynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。\n\nPriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。', '1', '0', '1', '1', '1', '', '3', 'admin', '2020-04-27 21:24:11', 'admin', '2020-04-27 21:24:11');
INSERT INTO `biz_article` VALUES ('13', '1', '1', '正则', '正则', '', '1', '<p><img src=\"/profile/upload/2020/07/01/1593615999127.png\" alt=\"2020/07/01/1593615999127.png =1127*576\"> </p>\n<p><img src=\"/profile/upload/2020/07/01/1593616025325.png\" alt=\"2020/07/01/1593616025325.png =984*557\"> </p>\n', '\n![2020/07/01/1593615999127.png =1127*576](/profile/upload/2020/07/01/1593615999127.png) \n\n![2020/07/01/1593616025325.png =984*557](/profile/upload/2020/07/01/1593616025325.png) ', '1', '0', '1', '1', '1', '', '4', 'admin', '2020-05-13 00:00:11', 'admin', '2020-07-01 23:07:31');
INSERT INTO `biz_article` VALUES ('14', '1', '1', '什么是正则表达式？', '正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。', '', '1', '<h2 id=\"什么是正则表达式？\">什么是正则表达式？</h2>\n<blockquote>\n<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>\n</blockquote>\n<p>一个正则表达式是一种从左到右匹配主体字符串的模式。\n“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。\n正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>\n<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。\n我们使用以下正则表达式来验证一个用户名：</p>\n<p><br/><br/></p>\n<p align=\"center\">\n  <img src=\"https://user-gold-cdn.xitu.io/2019/11/9/16e4f69159024002?w=480&h=322&f=png&s=18866\" alt=\"Regular expression\">\n</p>\n\n<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。\n但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>\n<h1 id=\"目录\">目录</h1>\n<ul>\n<li><a href=\"#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D\">1. 基本匹配</a></li>\n<li><a href=\"#2-%E5%85%83%E5%AD%97%E7%AC%A6\">2. 元字符</a><ul>\n<li><a href=\"#21-%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-\">2.1 点运算符 .</a></li>\n<li><a href=\"#22-%E5%AD%97%E7%AC%A6%E9%9B%86\">2.2 字符集</a><ul>\n<li><a href=\"#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86\">2.2.1 否定字符集</a><ul>\n<li><a href=\"#23-%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0\">2.3 重复次数</a></li>\n</ul>\n</li>\n<li><a href=\"#231--%E5%8F%B7\">2.3.1 * 号</a></li>\n<li><a href=\"#232--%E5%8F%B7\">2.3.2 + 号</a></li>\n<li><a href=\"#233--%E5%8F%B7\">2.3.3 ? 号</a><ul>\n<li><a href=\"#24--%E5%8F%B7\">2.4 {} 号</a></li>\n<li><a href=\"#25--%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4\">2.5 (...) 特征标群</a></li>\n<li><a href=\"#26--%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6\">2.6 | 或运算符</a></li>\n<li><a href=\"#27-%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6\">2.7 转码特殊字符</a></li>\n<li><a href=\"#28-%E9%94%9A%E7%82%B9\">2.8 锚点</a></li>\n</ul>\n</li>\n<li><a href=\"#281--%E5%8F%B7\">2.8.1 ^ 号</a></li>\n<li><a href=\"#282--%E5%8F%B7\">2.8.2 $ 号</a><ul>\n<li><a href=\"#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86\">3. 简写字符集</a></li>\n<li><a href=\"#4-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5\">4. 零宽度断言(前后预查)</a></li>\n<li><a href=\"#41--%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80\">4.1 ?=... 正先行断言</a></li>\n<li><a href=\"#42--%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80\">4.2 ?!... 负先行断言</a></li>\n<li><a href=\"#43---%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80\">4.3 ?&lt;= ... 正后发断言</a></li>\n<li><a href=\"#44--%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80\">4.4 ?&lt;!... 负后发断言</a></li>\n<li><a href=\"#5-%E6%A0%87%E5%BF%97\">5. 标志</a></li>\n<li><a href=\"#51-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive\">5.1 忽略大小写（Case Insensitive）</a></li>\n<li><a href=\"#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search\">5.2 全局搜索（Global search）</a></li>\n<li><a href=\"#53-%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline\">5.3 多行修饰符（Multiline）</a></li>\n<li><a href=\"#%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85\">额外补充</a></li>\n<li><a href=\"#%E8%B4%A1%E7%8C%AE\">贡献</a></li>\n<li><a href=\"#%E8%AE%B8%E5%8F%AF%E8%AF%81\">许可证</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-基本匹配\">1. 基本匹配</h2>\n<p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。\n例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>\n<pre>\n\"the\" => The fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/dmRygT/1\">在线练习</a></p>\n<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>\n<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/1paXsy/1\">在线练习</a></p>\n<h2 id=\"2-元字符\">2. 元字符</h2>\n<p>正则表达式主要依赖于元字符。\n元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">.</td>\n<td>句号匹配任意单个字符除了换行符。</td>\n</tr>\n<tr>\n<td align=\"center\">[ ]</td>\n<td>字符种类。匹配方括号内的任意字符。</td>\n</tr>\n<tr>\n<td align=\"center\">[^ ]</td>\n<td>否定的字符种类。匹配除了方括号里的任意字符</td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td>匹配&gt;=0个重复的在*号之前的字符。</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td>匹配&gt;=1个重复的+号前的字符。</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td>标记?之前的字符为可选.</td>\n</tr>\n<tr>\n<td align=\"center\">{n,m}</td>\n<td>匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td>\n</tr>\n<tr>\n<td align=\"center\">(xyz)</td>\n<td>字符集，匹配与 xyz 完全相等的字符串.</td>\n</tr>\n<tr>\n<td align=\"center\">&#124;</td>\n<td>或运算符，匹配符号前或后的字符.</td>\n</tr>\n<tr>\n<td align=\"center\">&#92;</td>\n<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code></td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td>从开始行开始匹配.</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td>从末端开始匹配.</td>\n</tr>\n</tbody></table>\n<h2 id=\"21-点运算符-\">2.1 点运算符 <code>.</code></h2>\n<p><code>.</code>是元字符中最简单的例子。\n<code>.</code>匹配任意单个字符，但不匹配换行符。\n例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>\n<pre>\n\".ar\" => The <a href=\"#learn-regex\"><strong>car</strong></a> <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n<p><a href=\"https://regex101.com/r/xc9GkU/1\">在线练习</a></p>\n<h2 id=\"22-字符集\">2.2 字符集</h2>\n<p>字符集也叫做字符类。\n方括号用来指定一个字符集。\n在方括号中使用连字符来指定字符集的范围。\n在方括号中的字符集不关心顺序。\n例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>\n<pre>\n\"[Tt]he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/2ITLQ4/1\">在线练习</a></p>\n<p>方括号的句号就表示句号。\n表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>\n<pre>\n\"ar[.]\" => A garage is a good place to park a c<a href=\"#learn-regex\"><strong>ar.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/wL3xtE/1\">在线练习</a></p>\n<h3 id=\"221-否定字符集\">2.2.1 否定字符集</h3>\n<p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。\n例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>\n<pre>\n\"[^c]ar\" => The car <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n<p><a href=\"https://regex101.com/r/nNNlq3/1\">在线练习</a></p>\n<h2 id=\"23-重复次数\">2.3 重复次数</h2>\n<p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。\n这些元字符在不同的情况下有着不同的意思。</p>\n<h3 id=\"231--号\">2.3.1 <code>*</code> 号</h3>\n<p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。\n例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>\n<pre>\n\"[a-z]*\" => T<a href=\"#learn-regex\"><strong>he</strong></a> <a href=\"#learn-regex\"><strong>car</strong></a> <a href=\"#learn-regex\"><strong>parked</strong></a> <a href=\"#learn-regex\"><strong>in</strong></a> <a href=\"#learn-regex\"><strong>the</strong></a> <a href=\"#learn-regex\"><strong>garage</strong></a> #21.\n</pre>\n\n<p><a href=\"https://regex101.com/r/7m8me5/1\">在线练习</a></p>\n<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。\n<code>*</code>和表示匹配空格的符号<code>\\s</code>连起来用，如表达式<code>\\s*cat\\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>\n<pre>\n\"\\s*cat\\s*\" => The fat<a href=\"#learn-regex\"><strong> cat </strong></a>sat on the con<a href=\"#learn-regex\"><strong>cat</strong></a>enation.\n</pre>\n\n<p><a href=\"https://regex101.com/r/gGrwuz/1\">在线练习</a></p>\n<h3 id=\"232--号\">2.3.2 <code>+</code> 号</h3>\n<p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。\n例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>\n<pre>\n\"c.+t\" => The fat <a href=\"#learn-regex\"><strong>cat sat on the mat</strong></a>.\n</pre>\n\n<p><a href=\"https://regex101.com/r/Dzf9Aa/1\">在线练习</a></p>\n<h3 id=\"233--号\">2.3.3 <code>?</code> 号</h3>\n<p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。\n例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>\n<pre>\n\"[T]he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/cIg9zm/1\">在线练习</a></p>\n<pre>\n\"[T]?he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in t<a href=\"#learn-regex\"><strong>he</strong></a> garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/kPpO2x/1\">在线练习</a></p>\n<h2 id=\"24--号\">2.4 <code>{}</code> 号</h2>\n<p>在正则表达式中 <code>{}</code> 是一个量词，常用来一个或一组字符可以重复出现的次数。\n例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>\n<pre>\n\"[0-9]{2,3}\" => The number was 9.<a href=\"#learn-regex\"><strong>999</strong></a>7 but we rounded it off to <a href=\"#learn-regex\"><strong>10</strong></a>.0.\n</pre>\n\n<p><a href=\"https://regex101.com/r/juM86s/1\">在线练习</a></p>\n<p>我们可以省略第二个参数。\n例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>\n<pre>\n\"[0-9]{2,}\" => The number was 9.<a href=\"#learn-regex\"><strong>9997</strong></a> but we rounded it off to <a href=\"#learn-regex\"><strong>10</strong></a>.0.\n</pre>\n\n<p><a href=\"https://regex101.com/r/Gdy4w5/1\">在线练习</a></p>\n<p>如果逗号也省略掉则表示重复固定的次数。\n例如，<code>[0-9]{3}</code> 匹配3位数字</p>\n<pre>\n\"[0-9]{3}\" => The number was 9.<a href=\"#learn-regex\"><strong>999</strong></a>7 but we rounded it off to 10.0.\n</pre>\n\n<p><a href=\"https://regex101.com/r/Sivu30/1\">在线练习</a></p>\n<h2 id=\"25--特征标群\">2.5 <code>(...)</code> 特征标群</h2>\n<p>特征标群是一组写在 <code>(...)</code> 中的子模式。例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。</p>\n<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>\n<pre>\n\"(c|g|p)ar\" => The <a href=\"#learn-regex\"><strong>car</strong></a> is <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n<p><a href=\"https://regex101.com/r/tUxrBG/1\">在线练习</a></p>\n<h2 id=\"26--或运算符\">2.6 <code>|</code> 或运算符</h2>\n<p>或运算符就表示或，用作判断条件。</p>\n<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>\n<pre>\n\"(T|t)he|car\" => <a href=\"#learn-regex\"><strong>The</strong></a> <a href=\"#learn-regex\"><strong>car</strong></a> is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/fBXyX0/1\">在线练习</a></p>\n<h2 id=\"27-转码特殊字符\">2.7 转码特殊字符</h2>\n<p>反斜线 <code>\\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\\</code>。</p>\n<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\\.</code> 以下这个例子 <code>\\.?</code>是选择性匹配<code>.</code></p>\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/DOc5Nu/1\">在线练习</a></p>\n<h2 id=\"28-锚点\">2.8 锚点</h2>\n<p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>\n<h3 id=\"281--号\">2.8.1 <code>^</code> 号</h3>\n<p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>\n<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>\n<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/5ljjgB/1\">在线练习</a></p>\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n<p><a href=\"https://regex101.com/r/jXrKne/1\">在线练习</a></p>\n<h3 id=\"282--号\">2.8.2 <code>$</code> 号</h3>\n<p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>\n<p>例如，<code>(at\\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/y4Au4D/1\">在线练习</a></p>\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/t0AkOd/1\">在线练习</a></p>\n<h2 id=\"3-简写字符集\">3. 简写字符集</h2>\n<p>正则表达式提供一些常用的字符集简写。如下:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">简写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">.</td>\n<td>除换行符外的所有字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\w</td>\n<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\W</td>\n<td>匹配所有非字母数字，即符号，等同于： <code>[^\\w]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\d</td>\n<td>匹配数字： <code>[0-9]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\D</td>\n<td>匹配非数字： <code>[^\\d]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\s</td>\n<td>匹配所有空格字符，等同于： <code>[\\t\\n\\f\\r\\p{Z}]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\S</td>\n<td>匹配所有非空格字符： <code>[^\\s]</code></td>\n</tr>\n<tr>\n<td align=\"center\">\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td align=\"center\">\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td align=\"center\">\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td align=\"center\">\\t</td>\n<td>匹配一个制表符</td>\n</tr>\n<tr>\n<td align=\"center\">\\v</td>\n<td>匹配一个垂直制表符</td>\n</tr>\n<tr>\n<td align=\"center\">\\p</td>\n<td>匹配 CR/LF（等同于 <code>\\r\\n</code>），用来匹配 DOS 行终止符</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-零宽度断言（前后预查）\">4. 零宽度断言（前后预查）</h2>\n<p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。\n先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p>\n<p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\\$)[0-9\\.]*</code>。\n这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p>\n<p>零宽度断言如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">?=</td>\n<td>正先行断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\">?!</td>\n<td>负先行断言-排除</td>\n</tr>\n<tr>\n<td align=\"center\">?&lt;=</td>\n<td>正后发断言-存在</td>\n</tr>\n<tr>\n<td align=\"center\">?&lt;!</td>\n<td>负后发断言-排除</td>\n</tr>\n</tbody></table>\n<h3 id=\"41--正先行断言\">4.1 <code>?=...</code> 正先行断言</h3>\n<p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>\n<p>返回结果只包含满足匹配条件的第一部分表达式。\n定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>\n<p>正先行断言的内容写在括号中的等号后面。\n例如，表达式 <code>(T|t)he(?=\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>\n<pre>\n\"(T|t)he(?=\\sfat)\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/IDDARt/1\">在线练习</a></p>\n<h3 id=\"42--负先行断言\">4.2 <code>?!...</code> 负先行断言</h3>\n<p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。\n<code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>\n<p>表达式 <code>(T|t)he(?!\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>\n<pre>\n\"(T|t)he(?!\\sfat)\" => The fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/V32Npg/1\">在线练习</a></p>\n<h3 id=\"43---正后发断言\">4.3 <code>?&lt;= ...</code> 正后发断言</h3>\n<p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。\n例如，表达式 <code>(?&lt;=(T|t)he\\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>\n<pre>\n\"(?<=(T|t)he\\s)(fat|mat)\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n<p><a href=\"https://regex101.com/r/avH165/1\">在线练习</a></p>\n<h3 id=\"44--负后发断言\">4.4 <code>?&lt;!...</code> 负后发断言</h3>\n<p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。\n例如，表达式 <code>(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>\n<pre>\n\"(?&lt;!(T|t)he\\s)(cat)\" => The cat sat on <a href=\"#learn-regex\"><strong>cat</strong></a>.\n</pre>\n\n<p><a href=\"https://regex101.com/r/8Efx5G/1\">在线练习</a></p>\n<h2 id=\"5-标志\">5. 标志</h2>\n<p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。\n这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">i</td>\n<td>忽略大小写。</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td>全局搜索。</td>\n</tr>\n<tr>\n<td align=\"center\">m</td>\n<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>\n</tr>\n</tbody></table>\n<h3 id=\"51-忽略大小写（case-insensitive）\">5.1 忽略大小写（Case Insensitive）</h3>\n<p>修饰语 <code>i</code> 用于忽略大小写。\n例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/dpQyf9/1\">在线练习</a></p>\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/ahfiuh/1\">在线练习</a></p>\n<h3 id=\"52-全局搜索（global-search）\">5.2 全局搜索（Global search）</h3>\n<p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。\n例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n<p><a href=\"https://regex101.com/r/jnk6gM/1\">在线练习</a></p>\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n<p><a href=\"https://regex101.com/r/dO1nef/1\">在线练习</a></p>\n<h3 id=\"53-多行修饰符（multiline）\">5.3 多行修饰符（Multiline）</h3>\n<p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>\n<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>\n<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/hoGMkP/1\">在线练习</a></p>\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n<p><a href=\"https://regex101.com/r/E88WE2/1\">在线练习</a></p>\n<h3 id=\"6-贪婪匹配与惰性匹配（greedy-vs-lazy-matching）\">6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）</h3>\n<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>\n<pre>\n\"/(.*at)/\" => <a href=\"#learn-regex\"><strong>The fat cat sat on the mat</strong></a>. </pre>\n\n<p><a href=\"https://regex101.com/r/AyAdgJ/1\">在线练习</a></p>\n<pre>\n\"/(.*?at)/\" => <a href=\"#learn-regex\"><strong>The fat</strong></a> cat sat on the mat. </pre>\n\n<p><a href=\"https://regex101.com/r/AyAdgJ/2\">在线练习</a></p>\n', '## 什么是正则表达式？\n\n> 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n\n一个正则表达式是一种从左到右匹配主体字符串的模式。\n“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。\n正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。\n\n想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。\n我们使用以下正则表达式来验证一个用户名：\n\n<br/><br/>\n\n<p align=\"center\">\n  <img src=\"https://user-gold-cdn.xitu.io/2019/11/9/16e4f69159024002?w=480&h=322&f=png&s=18866\" alt=\"Regular expression\">\n</p>\n\n以上的正则表达式可以接受 `john_doe`、`jo-hn_doe`、`john12_as`。\n但不匹配`Jo`，因为它包含了大写的字母而且太短了。\n\n目录\n=================\n\n * [1. 基本匹配](#1-基本匹配)\n * [2. 元字符](#2-元字符)\n 	* [2.1 点运算符 .](#21-点运算符-)\n 	* [2.2 字符集](#22-字符集)\n		* [2.2.1 否定字符集](#221-否定字符集)\n	* [2.3 重复次数](#23-重复次数)\n		* [2.3.1 * 号](#231--号)\n		* [2.3.2 + 号](#232--号)\n		* [2.3.3 ? 号](#233--号)\n	* [2.4 {} 号](#24--号)\n	* [2.5 (...) 特征标群](#25--特征标群)\n	* [2.6 | 或运算符](#26--或运算符)\n	* [2.7 转码特殊字符](#27-转码特殊字符)\n	* [2.8 锚点](#28-锚点)\n		* [2.8.1 ^ 号](#281--号)\n		* [2.8.2 $ 号](#282--号)\n* [3. 简写字符集](#3-简写字符集)\n* [4. 零宽度断言(前后预查)](#4-零宽度断言前后预查)\n	* [4.1 ?=... 正先行断言](#41--正先行断言)\n	* [4.2 ?!... 负先行断言](#42--负先行断言)\n	* [4.3 ?&lt;= ... 正后发断言](#43---正后发断言)\n	* [4.4 ?&lt;!... 负后发断言](#44--负后发断言)\n* [5. 标志](#5-标志)\n	* [5.1 忽略大小写（Case Insensitive）](#51-忽略大小写-case-insensitive)\n	* [5.2 全局搜索（Global search）](#52-全局搜索-global-search)\n	* [5.3 多行修饰符（Multiline）](#53-多行修饰符-multiline)\n* [额外补充](#额外补充)\n* [贡献](#贡献)\n* [许可证](#许可证)\n\n## 1. 基本匹配\n\n正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。\n例如：一个正则表达式 `the`，它表示一个规则：由字母`t`开始，接着是`h`，再接着是`e`。\n\n<pre>\n\"the\" => The fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n[在线练习](https://regex101.com/r/dmRygT/1)\n\n正则表达式`123`匹配字符串`123`。它逐个字符的与输入的正则表达式做比较。\n\n正则表达式是大小写敏感的，所以`The`不会匹配`the`。\n\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n[在线练习](https://regex101.com/r/1paXsy/1)\n\n## 2. 元字符\n\n正则表达式主要依赖于元字符。\n元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\n\n|元字符|描述|\n|:----:|----|\n|.|句号匹配任意单个字符除了换行符。|\n|[ ]|字符种类。匹配方括号内的任意字符。|\n|[^ ]|否定的字符种类。匹配除了方括号里的任意字符|\n|*|匹配>=0个重复的在*号之前的字符。|\n|+|匹配>=1个重复的+号前的字符。\n|?|标记?之前的字符为可选.|\n|{n,m}|匹配num个大括号之间的字符 (n <= num <= m).|\n|(xyz)|字符集，匹配与 xyz 完全相等的字符串.|\n|&#124;|或运算符，匹配符号前或后的字符.|\n|&#92;|转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code>|\n|^|从开始行开始匹配.|\n|$|从末端开始匹配.|\n\n## 2.1 点运算符 `.`\n\n`.`是元字符中最简单的例子。\n`.`匹配任意单个字符，但不匹配换行符。\n例如，表达式`.ar`匹配一个任意字符后面跟着是`a`和`r`的字符串。\n\n<pre>\n\".ar\" => The <a href=\"#learn-regex\"><strong>car</strong></a> <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n[在线练习](https://regex101.com/r/xc9GkU/1)\n\n## 2.2 字符集\n\n字符集也叫做字符类。\n方括号用来指定一个字符集。\n在方括号中使用连字符来指定字符集的范围。\n在方括号中的字符集不关心顺序。\n例如，表达式`[Tt]he` 匹配 `the` 和 `The`。\n\n<pre>\n\"[Tt]he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n[在线练习](https://regex101.com/r/2ITLQ4/1)\n\n方括号的句号就表示句号。\n表达式 `ar[.]` 匹配 `ar.`字符串\n\n<pre>\n\"ar[.]\" => A garage is a good place to park a c<a href=\"#learn-regex\"><strong>ar.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/wL3xtE/1)\n\n### 2.2.1 否定字符集\n\n一般来说 `^` 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。\n例如，表达式`[^c]ar` 匹配一个后面跟着`ar`的除了`c`的任意字符。\n\n<pre>\n\"[^c]ar\" => The car <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n[在线练习](https://regex101.com/r/nNNlq3/1)\n\n## 2.3 重复次数\n\n后面跟着元字符 `+`，`*` or `?` 的，用来指定匹配子模式的次数。\n这些元字符在不同的情况下有着不同的意思。\n\n### 2.3.1 `*` 号\n\n`*`号匹配 在`*`之前的字符出现`大于等于0`次。\n例如，表达式 `a*` 匹配0或更多个以a开头的字符。表达式`[a-z]*` 匹配一个行中所有以小写字母开头的字符串。\n\n<pre>\n\"[a-z]*\" => T<a href=\"#learn-regex\"><strong>he</strong></a> <a href=\"#learn-regex\"><strong>car</strong></a> <a href=\"#learn-regex\"><strong>parked</strong></a> <a href=\"#learn-regex\"><strong>in</strong></a> <a href=\"#learn-regex\"><strong>the</strong></a> <a href=\"#learn-regex\"><strong>garage</strong></a> #21.\n</pre>\n\n[在线练习](https://regex101.com/r/7m8me5/1)\n\n`*`字符和`.`字符搭配可以匹配所有的字符`.*`。\n`*`和表示匹配空格的符号`\\s`连起来用，如表达式`\\s*cat\\s*`匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。\n\n<pre>\n\"\\s*cat\\s*\" => The fat<a href=\"#learn-regex\"><strong> cat </strong></a>sat on the con<a href=\"#learn-regex\"><strong>cat</strong></a>enation.\n</pre>\n\n[在线练习](https://regex101.com/r/gGrwuz/1)\n\n### 2.3.2 `+` 号\n\n`+`号匹配`+`号之前的字符出现 >=1 次。\n例如表达式`c.+t` 匹配以首字母`c`开头以`t`结尾，中间跟着至少一个字符的字符串。\n\n<pre>\n\"c.+t\" => The fat <a href=\"#learn-regex\"><strong>cat sat on the mat</strong></a>.\n</pre>\n\n[在线练习](https://regex101.com/r/Dzf9Aa/1)\n\n### 2.3.3 `?` 号\n\n在正则表达式中元字符 `?` 标记在符号前面的字符为可选，即出现 0 或 1 次。\n例如，表达式 `[T]?he` 匹配字符串 `he` 和 `The`。\n\n<pre>\n\"[T]he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n[在线练习](https://regex101.com/r/cIg9zm/1)\n\n<pre>\n\"[T]?he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in t<a href=\"#learn-regex\"><strong>he</strong></a> garage.\n</pre>\n\n[在线练习](https://regex101.com/r/kPpO2x/1)\n\n## 2.4 `{}` 号\n\n在正则表达式中 `{}` 是一个量词，常用来一个或一组字符可以重复出现的次数。\n例如， 表达式 `[0-9]{2,3}` 匹配最少 2 位最多 3 位 0~9 的数字。\n\n<pre>\n\"[0-9]{2,3}\" => The number was 9.<a href=\"#learn-regex\"><strong>999</strong></a>7 but we rounded it off to <a href=\"#learn-regex\"><strong>10</strong></a>.0.\n</pre>\n\n[在线练习](https://regex101.com/r/juM86s/1)\n\n我们可以省略第二个参数。\n例如，`[0-9]{2,}` 匹配至少两位 0~9 的数字。\n\n<pre>\n\"[0-9]{2,}\" => The number was 9.<a href=\"#learn-regex\"><strong>9997</strong></a> but we rounded it off to <a href=\"#learn-regex\"><strong>10</strong></a>.0.\n</pre>\n\n[在线练习](https://regex101.com/r/Gdy4w5/1)\n\n如果逗号也省略掉则表示重复固定的次数。\n例如，`[0-9]{3}` 匹配3位数字\n\n<pre>\n\"[0-9]{3}\" => The number was 9.<a href=\"#learn-regex\"><strong>999</strong></a>7 but we rounded it off to 10.0.\n</pre>\n\n[在线练习](https://regex101.com/r/Sivu30/1)\n\n## 2.5 `(...)` 特征标群\n\n特征标群是一组写在 `(...)` 中的子模式。例如之前说的 `{}` 是用来表示前面一个字符出现指定次数。但如果在 `{}` 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 `(ab)*` 匹配连续出现 0 或更多个 `ab`。\n\n我们还可以在 `()` 中用或字符 `|` 表示或。例如，`(c|g|p)ar` 匹配 `car` 或 `gar` 或 `par`.\n\n<pre>\n\"(c|g|p)ar\" => The <a href=\"#learn-regex\"><strong>car</strong></a> is <a href=\"#learn-regex\"><strong>par</strong></a>ked in the <a href=\"#learn-regex\"><strong>gar</strong></a>age.\n</pre>\n\n[在线练习](https://regex101.com/r/tUxrBG/1)\n\n## 2.6 `|` 或运算符\n\n或运算符就表示或，用作判断条件。\n\n例如 `(T|t)he|car` 匹配 `(T|t)he` 或 `car`。\n\n<pre>\n\"(T|t)he|car\" => <a href=\"#learn-regex\"><strong>The</strong></a> <a href=\"#learn-regex\"><strong>car</strong></a> is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n[在线练习](https://regex101.com/r/fBXyX0/1)\n\n## 2.7 转码特殊字符\n\n反斜线 `\\` 在表达式中用于转码紧跟其后的字符。用于指定 `{ } [ ] / \\ + * . $ ^ | ?` 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 `\\`。\n\n例如 `.` 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 `.` 则要写成 `\\.` 以下这个例子 `\\.?`是选择性匹配`.`\n\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/DOc5Nu/1)\n\n## 2.8 锚点\n\n在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。`^` 指定开头，`$` 指定结尾。\n\n### 2.8.1 `^` 号\n\n`^` 用来检查匹配的字符串是否在所匹配字符串的开头。\n\n例如，在 `abc` 中使用表达式 `^a` 会得到结果 `a`。但如果使用 `^b` 将匹配不到任何结果。因为在字符串 `abc` 中并不是以 `b` 开头。\n\n例如，`^(T|t)he` 匹配以 `The` 或 `the` 开头的字符串。\n\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n[在线练习](https://regex101.com/r/5ljjgB/1)\n\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n[在线练习](https://regex101.com/r/jXrKne/1)\n\n### 2.8.2 `$` 号\n\n同理于 `^` 号，`$` 号用来匹配字符是否是最后一个。\n\n例如，`(at\\.)$` 匹配以 `at.` 结尾的字符串。\n\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/y4Au4D/1)\n\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/t0AkOd/1)\n\n##  3. 简写字符集\n\n正则表达式提供一些常用的字符集简写。如下:\n\n|简写|描述|\n|:----:|----|\n|.|除换行符外的所有字符|\n|\\w|匹配所有字母数字，等同于 `[a-zA-Z0-9_]`|\n|\\W|匹配所有非字母数字，即符号，等同于： `[^\\w]`|\n|\\d|匹配数字： `[0-9]`|\n|\\D|匹配非数字： `[^\\d]`|\n|\\s|匹配所有空格字符，等同于： `[\\t\\n\\f\\r\\p{Z}]`|\n|\\S|匹配所有非空格字符： `[^\\s]`|\n|\\f|匹配一个换页符|\n|\\n|匹配一个换行符|\n|\\r|匹配一个回车符|\n|\\t|匹配一个制表符|\n|\\v|匹配一个垂直制表符|\n|\\p|匹配 CR/LF（等同于 `\\r\\n`），用来匹配 DOS 行终止符|\n\n## 4. 零宽度断言（前后预查）\n\n先行断言和后发断言都属于**非捕获簇**（不捕获文本 ，也不针对组合计进行计数）。\n先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。\n\n例如，我们想要获得所有跟在 `$` 符号后的数字，我们可以使用正后发断言 `(?<=\\$)[0-9\\.]*`。\n这个表达式匹配 `$` 开头，之后跟着 `0,1,2,3,4,5,6,7,8,9,.` 这些字符可以出现大于等于 0 次。\n\n零宽度断言如下：\n\n|符号|描述|\n|:----:|----|\n|?=|正先行断言-存在|\n|?!|负先行断言-排除|\n|?<=|正后发断言-存在|\n|?<!|负后发断言-排除|\n\n### 4.1 `?=...` 正先行断言\n\n`?=...` 正先行断言，表示第一部分表达式之后必须跟着 `?=...`定义的表达式。\n\n返回结果只包含满足匹配条件的第一部分表达式。\n定义一个正先行断言要使用 `()`。在括号内部使用一个问号和等号： `(?=...)`。\n\n正先行断言的内容写在括号中的等号后面。\n例如，表达式 `(T|t)he(?=\\sfat)` 匹配 `The` 和 `the`，在括号中我们又定义了正先行断言 `(?=\\sfat)` ，即 `The` 和 `the` 后面紧跟着 `(空格)fat`。\n\n<pre>\n\"(T|t)he(?=\\sfat)\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n[在线练习](https://regex101.com/r/IDDARt/1)\n\n### 4.2 `?!...` 负先行断言\n\n负先行断言 `?!` 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。\n`正先行断言`  定义和 `负先行断言` 一样，区别就是 `=` 替换成 `!` 也就是 `(?!...)`。\n\n表达式 `(T|t)he(?!\\sfat)` 匹配 `The` 和 `the`，且其后不跟着 `(空格)fat`。\n\n<pre>\n\"(T|t)he(?!\\sfat)\" => The fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n[在线练习](https://regex101.com/r/V32Npg/1)\n\n### 4.3 `?<= ...` 正后发断言\n\n正后发断言 记作`(?<=...)` 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。\n例如，表达式 `(?<=(T|t)he\\s)(fat|mat)` 匹配 `fat` 和 `mat`，且其前跟着 `The` 或 `the`。\n\n<pre>\n\"(?<=(T|t)he\\s)(fat|mat)\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n[在线练习](https://regex101.com/r/avH165/1)\n\n### 4.4 `?<!...` 负后发断言\n\n负后发断言 记作 `(?<!...)` 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。\n例如，表达式 `(?<!(T|t)he\\s)(cat)` 匹配 `cat`，且其前不跟着 `The` 或 `the`。\n\n<pre>\n\"(?&lt;!(T|t)he\\s)(cat)\" => The cat sat on <a href=\"#learn-regex\"><strong>cat</strong></a>.\n</pre>\n\n[在线练习](https://regex101.com/r/8Efx5G/1)\n\n## 5. 标志\n\n标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。\n这些标志可以任意的组合使用，它也是整个正则表达式的一部分。\n\n|标志|描述|\n|:----:|----|\n|i|忽略大小写。|\n|g|全局搜索。|\n|m|多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始。|\n\n### 5.1 忽略大小写（Case Insensitive）\n\n修饰语 `i` 用于忽略大小写。\n例如，表达式 `/The/gi` 表示在全局搜索 `The`，在后面的 `i` 将其条件修改为忽略大小写，则变成搜索 `the` 和 `The`，`g` 表示全局搜索。\n\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n[在线练习](https://regex101.com/r/dpQyf9/1)\n\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n[在线练习](https://regex101.com/r/ahfiuh/1)\n\n### 5.2 全局搜索（Global search）\n\n修饰符 `g` 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。\n例如，表达式 `/.(at)/g` 表示搜索 任意字符（除了换行）+ `at`，并返回全部结果。\n\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n[在线练习](https://regex101.com/r/jnk6gM/1)\n\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n[在线练习](https://regex101.com/r/dO1nef/1)\n\n### 5.3 多行修饰符（Multiline）\n\n多行修饰符 `m` 常用于执行一个多行匹配。\n\n像之前介绍的 `(^,$)` 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 `m`。\n\n例如，表达式 `/at(.)?$/gm` 表示小写字符 `a` 后跟小写字符 `t` ，末尾可选除换行符外任意字符。根据 `m` 修饰符，现在表达式匹配每行的结尾。\n\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/hoGMkP/1)\n\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n[在线练习](https://regex101.com/r/E88WE2/1)\n\n### 6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）\n\n正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 `?` 将贪婪匹配模式转化为惰性匹配模式。\n\n<pre>\n\"/(.*at)/\" => <a href=\"#learn-regex\"><strong>The fat cat sat on the mat</strong></a>. </pre>\n\n[在线练习](https://regex101.com/r/AyAdgJ/1)\n\n<pre>\n\"/(.*?at)/\" => <a href=\"#learn-regex\"><strong>The fat</strong></a> cat sat on the mat. </pre>\n\n[在线练习](https://regex101.com/r/AyAdgJ/2)', '1', '0', '1', '1', '1', '', '2', 'admin', '2020-05-13 00:02:21', 'admin', '2020-05-13 00:02:21');
INSERT INTO `biz_article` VALUES ('15', '1', '12', '解决Python中pip/pip3下载速度慢', 'PyPI (Python Package Index) 是 Python 编程语言的软件存储库。开发者可以通过 PyPI 查找和安装由 Python 社区开发和共享的软件，也可以将自己开发的库上传至 PyPI 。', '', '1', '<h1 id=\"pypi-镜像\">PyPI 镜像</h1>\n<h2 id=\"简介\">简介</h2>\n<p>PyPI (Python Package Index) 是 Python 编程语言的软件存储库。开发者可以通过 PyPI 查找和安装由 Python 社区开发和共享的软件，也可以将自己开发的库上传至 PyPI 。</p>\n<h2 id=\"linux下更换pip源\">Linux下更换pip源</h2>\n<p>使用pip/pip3安装一些python包的时候下载速度非常慢，这时候我们可以动手更换python的pip/pip3源，在Linux系统中找到<code>~/.pip/pip.conf</code>这个文件，如果没有这个文件自己创建一个同名文件，或者你的系统连<code>~./pip</code>这个目录也没有，那就自己创建一个目录并且在目录中创建一个<code>pip.conf</code>文件，并向该文件添加或修改成以下内容。</p>\n<pre><code>[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=mirrors.aliyun.com</code></pre><h2 id=\"windows下更换pip源\">windows下更换pip源</h2>\n<ol>\n<li>文件管理器的地址栏输入<code>%appdata%</code>回车进入当前用户主目录</li>\n<li>在当前文件夹下新建文件夹<code>pip</code></li>\n<li>在pip文件夹下新建文件<code>pip.ini</code>文件</li>\n<li>在<code>pip.ini</code>文件中输入以下内容</li>\n</ol>\n<pre><code>[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=mirrors.aliyun.com</code></pre>', '# PyPI 镜像\n## 简介\nPyPI (Python Package Index) 是 Python 编程语言的软件存储库。开发者可以通过 PyPI 查找和安装由 Python 社区开发和共享的软件，也可以将自己开发的库上传至 PyPI 。\n\n## Linux下更换pip源\n使用pip/pip3安装一些python包的时候下载速度非常慢，这时候我们可以动手更换python的pip/pip3源，在Linux系统中找到`~/.pip/pip.conf`这个文件，如果没有这个文件自己创建一个同名文件，或者你的系统连`~./pip`这个目录也没有，那就自己创建一个目录并且在目录中创建一个`pip.conf`文件，并向该文件添加或修改成以下内容。\n\n```\n[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=mirrors.aliyun.com\n```\n\n## windows下更换pip源\n1. 文件管理器的地址栏输入`%appdata%`回车进入当前用户主目录\n2. 在当前文件夹下新建文件夹`pip`\n3. 在pip文件夹下新建文件`pip.ini`文件\n4. 在`pip.ini`文件中输入以下内容\n\n```\n[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=mirrors.aliyun.com\n```\n', '1', '0', '1', '1', '1', '', '3', 'admin', '2020-05-25 21:42:02', 'admin', '2020-05-25 21:44:02');
INSERT INTO `biz_article` VALUES ('17', '1', '2', '初次尝试', '13', '', '1', '<h1 id=\"-\">这是一级标题</h1>\n<h2 id=\"-\">这是二级标题</h2>\n<h3 id=\"-\">这是三级标题</h3>\n<h4 id=\"-\">这是四级标题</h4>\n<h5 id=\"-\">这是五级标题</h5>\n<h6 id=\"-\">这是六级标题</h6>\n<hr>\n<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>\n<hr>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>这是引用的内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<hr>\n<hr>\n<hr>\n<hr>\n<p><img src=\"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/\nu=702257389,1274025419&amp;fm=27&amp;gp=0.jpg\" alt=\"blockchain\" title=\"区块链\"></p>\n<hr>\n<p><a href=\"http://jianshu.com\">简书</a><br><a href=\"http://baidu.com\">百度</a></p>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ol>\n<li>列表内容</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<hr>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th style=\"text-align:center\">技能</th>\n<th style=\"text-align:right\">排行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>刘备</td>\n<td style=\"text-align:center\">哭</td>\n<td style=\"text-align:right\">大哥</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td style=\"text-align:center\">打</td>\n<td style=\"text-align:right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td style=\"text-align:center\">骂</td>\n<td style=\"text-align:right\">三弟</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><code>create database hero;</code></p>\n<pre class=\" language-php\"><code class=\" language-php\">    <span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">echo</span> <span class=\"token string\">\"这是一句非常牛逼的代码\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<hr>\n<pre class=\" language-flow\"><code class=\" language-flow\">st=&gt;start: 开始\nop=&gt;operation: My Operation\ncond=&gt;condition: Yes or No?\ne=&gt;end\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</code></pre>\n', '# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n\n---\n\n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n---\n\n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n\n\n\n---\n\n----\n***\n*****\n\n![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/\nu=702257389,1274025419&fm=27&gp=0.jpg \"区块链\")\n\n\n---\n\n[简书](http://jianshu.com)\n[百度](http://baidu.com)\n\n\n\n- 列表内容\n+ 列表内容\n* 列表内容\n\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n\n---\n\n姓名|技能|排行\n--|:--:|--:\n刘备|哭|大哥\n关羽|打|二哥\n张飞|骂|三弟\n\n\n---\n\n`create database hero;`\n\n```php\n    function fun(){\n         echo \"这是一句非常牛逼的代码\";\n    }\n    fun();\n```\n\n---\n\n```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```', '0', '0', '1', '1', '1', '', '1', 'admin', '2020-06-29 23:44:08', 'admin', '2020-06-29 23:44:53');
INSERT INTO `biz_article` VALUES ('19', '1', '3', '单例模式', '', '/profile/upload/2020/07/01/10.jpg', '1', '<h3 id=\"-\">饿汉式</h3>\n<p><code>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</code></p>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-java\" style=\"white-space: pre-wrap;\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 首先，也是先堵死 new Singleton() 这条路</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Singleton</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 加锁</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 这一次判断也是必须的，不然会有并发问题</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h3 id=\"-\">饱汉式</h3>\n<p><code>双重检查，指的是两次检查 instance 是否为 null。</code><br><code>volatile 在这里是需要的，希望能引起读者的关注。</code><br><code>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</code></p>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-java\" style=\"white-space: pre-wrap;\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 首先，也是先堵死 new Singleton() 这条路</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Singleton</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 加锁</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// 这一次判断也是必须的，不然会有并发问题</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h3 id=\"-\">嵌套类</h3>\n<p><code>注意，很多人都会把这个嵌套类说成是静态内部类，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</code></p>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-java\" style=\"white-space: pre-wrap;\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton3</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Holder</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton3</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton3</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Holder</span><span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n', '### 饿汉式\n`很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。`\n\n\n```java\npublic class Singleton {\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() {}\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            // 加锁\n            synchronized (Singleton.class) {\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 饱汉式\n\n`双重检查，指的是两次检查 instance 是否为 null。`\n`volatile 在这里是需要的，希望能引起读者的关注。`\n`很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。`\n\n```java\npublic class Singleton {\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() {}\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            // 加锁\n            synchronized (Singleton.class) {\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 嵌套类\n`注意，很多人都会把这个嵌套类说成是静态内部类，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。`\n\n```java\npublic class Singleton3 {\n\n    private Singleton3() {}\n    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性\n    private static class Holder {\n        private static Singleton3 instance = new Singleton3();\n    }\n    public static Singleton3 getInstance() {\n        return Holder.instance;\n    }\n}\n```\n\n\n', '1', '1', '1', '1', '1', '', '4', 'admin', '2020-07-01 23:03:01', 'admin', '2020-07-01 23:03:01');
INSERT INTO `biz_article` VALUES ('20', '1', '2', '随便写的', 'llan', '/profile/upload/2020/07/04/00.jpg', '1', '<p><img src=\"/profile/upload/2020/07/04/1593851451673.jpg\" alt=\"2020/07/04/1593851451673.jpg =200*200\"> </p>\n<p><img src=\"/profile/upload/2020/07/04/1593851489222.jpg\" alt=\"2020/07/04/1593851489222.jpg =586*352\"> </p>\n<p><img src=\"/profile/upload/2020/07/04/1593851534424.png\" alt=\"2020/07/04/1593851534424.png =322*322\"> </p>\n<hr>\n<blockquote>\n<p>啦啦啦。我是卖报的小行家，， 哈哈哈</p>\n</blockquote>\n<h4 id=\"-\">报数</h4>\n<ol>\n<li>1</li>\n<li>2</li>\n<li>3</li>\n<li>4</li>\n<li>5</li>\n</ol>\n<hr>\n<p><strong><font color=\"red\">没有</font>了 ， 是<del><em>真的</em></del>吗 ?</strong></p>\n', '![2020/07/04/1593851451673.jpg =200*200](/profile/upload/2020/07/04/1593851451673.jpg) \n\n![2020/07/04/1593851489222.jpg =586*352](/profile/upload/2020/07/04/1593851489222.jpg) \n\n\n\n\n![2020/07/04/1593851534424.png =322*322](/profile/upload/2020/07/04/1593851534424.png) \n\n\n------------\n\n\n\n> 啦啦啦。我是卖报的小行家，， 哈哈哈\n\n\n#### 报数\n1. 1\n2. 2\n3. 3\n4. 4\n5. 5\n\n\n\n\n------------\n\n**<font color=\'red\'>没有</font>了 ， 是~~*真的*~~吗 ?**', '0', '0', '1', '1', '1', '', '2', 'admin', '2020-07-04 16:34:08', 'admin', '2020-07-05 15:07:32');
INSERT INTO `biz_article` VALUES ('21', '1', '12', 'Python面向对象', '', '', '1', '<h2 id=\"-\">面向对象技术简介</h2>\n<ul>\n<li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>\n<li><strong>方法：</strong>类中定义的函数。</li>\n<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>\n<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>\n<li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>\n<li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>\n<li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li>\n<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。</li>\n<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>\n<li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>\n</ul>\n<h2 id=\"-\">类对象</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\'\'\'\n类对象\n\'\'\'</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 一个简单的类实例</span>\n    i <span class=\"token operator\">=</span> <span class=\"token number\">12345</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello world\"</span>\n\n<span class=\"token comment\"># 实例化类</span>\nx <span class=\"token operator\">=</span> MyClass<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 访问类的属性和方法</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'MyClass 类的属性 i 为： \'</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'MyClass 类的方法 f 输出为： \'</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">.</span>f<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">类的方法</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\'\'\'\n类的方法\n\'\'\'</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">people</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 定义基本属性</span>\n    name <span class=\"token operator\">=</span> <span class=\"token string\">\'\'</span>\n    age <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\"># 定义私有属性,私有属性在类外部无法直接进行访问</span>\n    __weight <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token comment\"># 定义构造方法</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> n\n        self<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> a\n        self<span class=\"token punctuation\">.</span>__weight <span class=\"token operator\">=</span> w\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">speak</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s 说: 我 %d 岁。\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\"># 实例化类</span>\np <span class=\"token operator\">=</span> people<span class=\"token punctuation\">(</span><span class=\"token string\">\'runoob\'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>speak<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">继承</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\">\n<span class=\"token triple-quoted-string string\">\'\'\'\n继承\n\'\'\'</span>\n<span class=\"token comment\"># 单继承示例</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">student</span><span class=\"token punctuation\">(</span>people<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    grade <span class=\"token operator\">=</span> <span class=\"token string\">\'\'</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 调用父类的构函</span>\n        people<span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>grade <span class=\"token operator\">=</span> g\n\n    <span class=\"token comment\"># 覆写父类的方法</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">speak</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s 说: 我 %d 岁了，我在读 %d 年级\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>grade<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\ns <span class=\"token operator\">=</span> student<span class=\"token punctuation\">(</span><span class=\"token string\">\'ken\'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>speak<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 72px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">多继承</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\">\n<span class=\"token triple-quoted-string string\">\'\'\'\n多继承\n\'\'\'</span>\n<span class=\"token comment\"># 另一个类，多重继承之前的准备</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">speaker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    topic <span class=\"token operator\">=</span> <span class=\"token string\">\'\'</span>\n    name <span class=\"token operator\">=</span> <span class=\"token string\">\'\'</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> n\n        self<span class=\"token punctuation\">.</span>topic <span class=\"token operator\">=</span> t\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">speak</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>topic<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\"># 多重继承</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">sample</span><span class=\"token punctuation\">(</span>speaker<span class=\"token punctuation\">,</span> student<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> <span class=\"token string\">\'\'</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        student<span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">)</span>\n        speaker<span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n\n\ntest <span class=\"token operator\">=</span> sample<span class=\"token punctuation\">(</span><span class=\"token string\">\"Tim\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token number\">80</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Python\"</span><span class=\"token punctuation\">)</span>\ntest<span class=\"token punctuation\">.</span>speak<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 方法名同，默认调用的是在括号中排前地父类的方法</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 72px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">方法重写</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\">\n<span class=\"token triple-quoted-string string\">\'\'\'\n方法重写\n\'\'\'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 定义父类</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">myMethod</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'调用父类方法\'</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span>Parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 定义子类</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">myMethod</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'调用子类方法\'</span><span class=\"token punctuation\">)</span>\n\n\nc <span class=\"token operator\">=</span> Child<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 子类实例</span>\nc<span class=\"token punctuation\">.</span>myMethod<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 子类调用重写方法</span>\n<span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>Child<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>myMethod<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 用子类对象调用父类已被覆盖的方法</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">类属性与方法</h2>\n<blockquote>\n<p>类的私有属性  </p>\n</blockquote>\n<p><strong>__private_attrs：</strong>两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p>\n<blockquote>\n<p>类的方法  </p>\n</blockquote>\n<p>在类的内部，使用 <code>def</code> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <code>self</code>，且为第一个参数，<code>self</code> 代表的是类的实例。</p>\n<p><code>self</code> 的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定是用 <code>self</code>。</p>\n<blockquote>\n<p>类的私有方法  </p>\n</blockquote>\n<p><strong>__private_method：</strong>两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p>\n<h2 id=\"-\">类的私有属性</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\'\'\'\n类的私有属性 \n\'\'\'</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">JustCounter</span><span class=\"token punctuation\">:</span>\n    __secretCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 私有变量</span>\n    publicCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 公开变量</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>__secretCount <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        self<span class=\"token punctuation\">.</span>publicCount <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>__secretCount<span class=\"token punctuation\">)</span>\n\n\ncounter <span class=\"token operator\">=</span> JustCounter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncounter<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncounter<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>publicCount<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>__secretCount<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 报错，实例不能访问私有变量</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">类的私有方法</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\">\n<span class=\"token triple-quoted-string string\">\'\'\'\n类的私有方法\n\'\'\'</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Site</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name  <span class=\"token comment\"># public</span>\n        self<span class=\"token punctuation\">.</span>__url <span class=\"token operator\">=</span> url  <span class=\"token comment\"># private</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">who</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'name  : \'</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'url : \'</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>__url<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__foo</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 私有方法</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'这是私有方法\'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 公共方法</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\'这是公共方法\'</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>__foo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\nx <span class=\"token operator\">=</span> Site<span class=\"token punctuation\">(</span><span class=\"token string\">\'菜鸟教程\'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\'www.runoob.com\'</span><span class=\"token punctuation\">)</span>\nx<span class=\"token punctuation\">.</span>who<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 正常输出</span>\nx<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 正常输出</span>\nx<span class=\"token punctuation\">.</span>__foo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 报错</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n<h2 id=\"-\">类的专有方法</h2>\n<ul>\n<li><strong>init</strong> : 构造函数，在生成对象时调用</li>\n<li><strong>del</strong> : 析构函数，释放对象时使用</li>\n<li><strong>repr</strong> : 打印，转换</li>\n<li><strong>setitem</strong> : 按照索引赋值</li>\n<li><strong>getitem</strong>: 按照索引获取值</li>\n<li><strong>len</strong>: 获得长度</li>\n<li><strong>cmp</strong>: 比较运算</li>\n<li><strong>call</strong>: 函数调用</li>\n<li><strong>add</strong>: 加运算</li>\n<li><strong>sub</strong>: 减运算</li>\n<li><strong>mul</strong>: 乘运算</li>\n<li><strong>truediv</strong>: 除运算</li>\n<li><strong>mod</strong>: 求余运算</li>\n<li><strong>pow</strong>: 乘方</li>\n</ul>\n<h2 id=\"-\">运算符重载</h2>\n<div class=\"code-toolbar\"><pre class=\"line-numbers language-python\" style=\"white-space: pre-wrap;\"><code class=\"language-python\"><span class=\"token triple-quoted-string string\">\'\'\'\n运算符重载\n\'\'\'</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> a\n        self<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> b\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__str__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\'Vector (%d, %d)\'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__add__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Vector<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>a <span class=\"token operator\">+</span> other<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>b <span class=\"token operator\">+</span> other<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n\n\nv1 <span class=\"token operator\">=</span> Vector<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\nv2 <span class=\"token operator\">=</span> Vector<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>v1 <span class=\"token operator\">+</span> v2<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 48px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span><span style=\"height: 24px;\"></span></span><span class=\"line-numbers-sizer\" style=\"display: none;\"></span></code></pre><div class=\"toolbar\"><div class=\"toolbar-item\"><button>Copy</button></div></div></div>\n', '## 面向对象技术简介\n- **类(Class):** 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n- **方法：**类中定义的函数。\n- **类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n- **数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。\n- **方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n- **局部变量：**定义在方法中的变量，只作用于当前实例的类。\n- **实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。\n- **继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。\n- **实例化：**创建一个类的实例，类的具体对象。\n- 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n\n## 类对象\n``` python\n\'\'\'\n类对象\n\'\'\'\nclass MyClass:\n    # 一个简单的类实例\n    i = 12345\n    def f(self):\n        return \"hello world\"\n\n# 实例化类\nx = MyClass()\n\n# 访问类的属性和方法\nprint(\'MyClass 类的属性 i 为： \', x.i)\nprint(\'MyClass 类的方法 f 输出为： \', x.f())\n```\n\n## 类的方法\n``` python\n\'\'\'\n类的方法\n\'\'\'\nclass people:\n    # 定义基本属性\n    name = \'\'\n    age = 0\n    # 定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n\n    # 定义构造方法\n    def __init__(self, n, a, w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" % (self.name, self.age))\n\n\n# 实例化类\np = people(\'runoob\', 10, 30)\np.speak()\n\n```\n\n## 继承\n``` python\n\n\'\'\'\n继承\n\'\'\'\n# 单继承示例\nclass student(people):\n    grade = \'\'\n\n    def __init__(self, n, a, w, g):\n        # 调用父类的构函\n        people.__init__(self, n, a, w)\n        self.grade = g\n\n    # 覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\" % (self.name, self.age, self.grade))\n\n\ns = student(\'ken\', 10, 60, 3)\ns.speak()\n\n```\n\n## 多继承\n``` python\n\n\'\'\'\n多继承\n\'\'\'\n# 另一个类，多重继承之前的准备\nclass speaker():\n    topic = \'\'\n    name = \'\'\n\n    def __init__(self, n, t):\n        self.name = n\n        self.topic = t\n\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\" % (self.name, self.topic))\n\n\n# 多重继承\nclass sample(speaker, student):\n    a = \'\'\n\n    def __init__(self, n, a, w, g, t):\n        student.__init__(self, n, a, w, g)\n        speaker.__init__(self, n, t)\n\n\ntest = sample(\"Tim\", 25, 80, 4, \"Python\")\ntest.speak()  # 方法名同，默认调用的是在括号中排前地父类的方法\n\n```\n\n## 方法重写\n``` python\n\n\'\'\'\n方法重写\n\'\'\'\n\nclass Parent:  # 定义父类\n    def myMethod(self):\n        print(\'调用父类方法\')\n\n\nclass Child(Parent):  # 定义子类\n    def myMethod(self):\n        print(\'调用子类方法\')\n\n\nc = Child()  # 子类实例\nc.myMethod()  # 子类调用重写方法\nsuper(Child, c).myMethod()  # 用子类对象调用父类已被覆盖的方法\n\n```\n\n## 类属性与方法\n> 类的私有属性  \n\n**__private_attrs：**两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 **self.__private_attrs**。\n\n> 类的方法  \n\n在类的内部，使用 `def` 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 `self`，且为第一个参数，`self` 代表的是类的实例。\n\n`self` 的名字并不是规定死的，也可以使用 `this`，但是最好还是按照约定是用 `self`。\n\n> 类的私有方法  \n\n**__private_method：**两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。**self.__private_methods**。\n\n\n## 类的私有属性 \n``` python\n\'\'\'\n类的私有属性 \n\'\'\'\nclass JustCounter:\n    __secretCount = 0  # 私有变量\n    publicCount = 0  # 公开变量\n\n    def count(self):\n        self.__secretCount += 1\n        self.publicCount += 1\n        print(self.__secretCount)\n\n\ncounter = JustCounter()\ncounter.count()\ncounter.count()\nprint(counter.publicCount)\nprint(counter.__secretCount)  # 报错，实例不能访问私有变量\n\n```\n\n## 类的私有方法\n``` python\n\n\'\'\'\n类的私有方法\n\'\'\'\nclass Site:\n    def __init__(self, name, url):\n        self.name = name  # public\n        self.__url = url  # private\n\n    def who(self):\n        print(\'name  : \', self.name)\n        print(\'url : \', self.__url)\n\n    def __foo(self):  # 私有方法\n        print(\'这是私有方法\')\n\n    def foo(self):  # 公共方法\n        print(\'这是公共方法\')\n        self.__foo()\n\n\nx = Site(\'菜鸟教程\', \'www.runoob.com\')\nx.who()  # 正常输出\nx.foo()  # 正常输出\nx.__foo()  # 报错\n```\n\n## 类的专有方法\n- __init__ : 构造函数，在生成对象时调用\n- __del__ : 析构函数，释放对象时使用\n- __repr__ : 打印，转换\n- __setitem__ : 按照索引赋值\n- __getitem__: 按照索引获取值\n- __len__: 获得长度\n- __cmp__: 比较运算\n- __call__: 函数调用\n- __add__: 加运算\n- __sub__: 减运算\n- __mul__: 乘运算\n- __truediv__: 除运算\n- __mod__: 求余运算\n- __pow__: 乘方\n\n## 运算符重载\n``` python \n\'\'\'\n运算符重载\n\'\'\'\nclass Vector:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def __str__(self):\n        return \'Vector (%d, %d)\' % (self.a, self.b)\n\n    def __add__(self, other):\n        return Vector(self.a + other.a, self.b + other.b)\n\n\nv1 = Vector(2, 10)\nv2 = Vector(5, -2)\nprint(v1 + v2)\n```', '1', '0', '1', '1', '1', '', '1', 'admin', '2020-09-02 21:52:15', 'admin', '2020-09-02 21:52:15');

-- ----------------------------
-- Table structure for `biz_article_tags`
-- ----------------------------
DROP TABLE IF EXISTS `biz_article_tags`;
CREATE TABLE `biz_article_tags` (
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `tag_id` bigint(20) NOT NULL COMMENT '标签Id',
  PRIMARY KEY (`article_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章和标签关联表';

-- ----------------------------
-- Records of biz_article_tags
-- ----------------------------
INSERT INTO `biz_article_tags` VALUES ('1', '1');
INSERT INTO `biz_article_tags` VALUES ('1', '16');
INSERT INTO `biz_article_tags` VALUES ('4', '1');
INSERT INTO `biz_article_tags` VALUES ('4', '7');
INSERT INTO `biz_article_tags` VALUES ('5', '1');
INSERT INTO `biz_article_tags` VALUES ('5', '18');
INSERT INTO `biz_article_tags` VALUES ('6', '1');
INSERT INTO `biz_article_tags` VALUES ('6', '18');
INSERT INTO `biz_article_tags` VALUES ('7', '19');
INSERT INTO `biz_article_tags` VALUES ('7', '20');
INSERT INTO `biz_article_tags` VALUES ('8', '1');
INSERT INTO `biz_article_tags` VALUES ('8', '3');
INSERT INTO `biz_article_tags` VALUES ('8', '8');
INSERT INTO `biz_article_tags` VALUES ('9', '21');
INSERT INTO `biz_article_tags` VALUES ('9', '22');
INSERT INTO `biz_article_tags` VALUES ('10', '16');
INSERT INTO `biz_article_tags` VALUES ('11', '16');
INSERT INTO `biz_article_tags` VALUES ('12', '1');
INSERT INTO `biz_article_tags` VALUES ('13', '23');
INSERT INTO `biz_article_tags` VALUES ('14', '23');
INSERT INTO `biz_article_tags` VALUES ('15', '24');
INSERT INTO `biz_article_tags` VALUES ('17', '16');
INSERT INTO `biz_article_tags` VALUES ('19', '1');
INSERT INTO `biz_article_tags` VALUES ('19', '18');
INSERT INTO `biz_article_tags` VALUES ('20', '14');
INSERT INTO `biz_article_tags` VALUES ('21', '24');

-- ----------------------------
-- Table structure for `biz_category`
-- ----------------------------
DROP TABLE IF EXISTS `biz_category`;
CREATE TABLE `biz_category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `parent_id` bigint(20) DEFAULT '0' COMMENT '父级ID',
  `name` varchar(50) NOT NULL COMMENT '类别名称',
  `alias` varchar(50) DEFAULT NULL COMMENT '类别别名(用于url访问)',
  `status` tinyint(1) DEFAULT '1' COMMENT '状态 0不显示 1显示',
  `nav` tinyint(1) DEFAULT '0' COMMENT '是否显示导航栏 0否 1是',
  `sort` int(4) DEFAULT '0' COMMENT '显示顺序',
  `color` varchar(10) DEFAULT '#3385FF' COMMENT '背景',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COMMENT='类别表';

-- ----------------------------
-- Records of biz_category
-- ----------------------------
INSERT INTO `biz_category` VALUES ('1', '0', '编程', 'software', '1', '1', '0', '', '', 'admin', '2020-02-16 12:30:57', 'admin', '2020-02-16 12:30:57');
INSERT INTO `biz_category` VALUES ('2', '0', '闲情', 'leisure', '1', '0', '1', '', '', 'admin', '2020-02-16 12:37:00', 'admin', '2020-04-13 22:41:11');
INSERT INTO `biz_category` VALUES ('3', '1', 'JAVA', 'java', '1', '1', '0', '#18e834', '', 'admin', '2020-02-16 13:42:05', 'admin', '2020-04-13 22:34:41');
INSERT INTO `biz_category` VALUES ('4', '1', 'HTML', 'html', '1', '1', '1', '', '', 'admin', '2020-02-16 13:43:04', 'admin', '2020-04-13 22:35:07');
INSERT INTO `biz_category` VALUES ('6', '2', '游戏', 'gg', '1', '1', '0', '', '', 'admin', '2020-02-17 04:19:58', 'admin', '2020-04-13 22:40:52');
INSERT INTO `biz_category` VALUES ('8', '0', '测试很长的', 'test', '0', '1', '2', '#e146f2', '', 'admin', '2020-02-17 06:18:58', 'admin', '2020-04-20 22:37:31');
INSERT INTO `biz_category` VALUES ('9', '4', '三级tag', 'tag', '1', '1', '0', '#9f13c2', '三级', 'admin', '2020-03-21 17:14:08', 'admin', '2020-04-13 22:35:39');
INSERT INTO `biz_category` VALUES ('11', '0', 'MySql', 'mysql', '1', '1', '0', '#dd00ff', 'MySql', 'admin', '2020-04-20 22:37:14', 'admin', '2020-04-20 22:37:14');
INSERT INTO `biz_category` VALUES ('12', '1', 'Python', 'python', '1', '1', '3', '#dd10f4', 'python ', 'admin', '2020-05-25 21:43:08', 'admin', '2020-05-25 21:43:08');

-- ----------------------------
-- Table structure for `biz_comment`
-- ----------------------------
DROP TABLE IF EXISTS `biz_comment`;
CREATE TABLE `biz_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `parent_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '父级评论的id,默认为0',
  `article_id` bigint(20) NOT NULL COMMENT '文章id',
  `user_id` bigint(20) DEFAULT NULL COMMENT '评论人的ID',
  `user_name` varchar(64) DEFAULT NULL,
  `qq` varchar(20) DEFAULT NULL COMMENT '评论人的QQ',
  `status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否审核通过 0-未审核 1-审核通过',
  `content` text NOT NULL COMMENT '评论内容',
  `thread` varchar(30) NOT NULL COMMENT '评论层级',
  `like_num` bigint(20) NOT NULL DEFAULT '0' COMMENT '点赞数',
  `ip` varchar(255) DEFAULT NULL COMMENT 'ip地址',
  `address` varchar(255) DEFAULT '' COMMENT '评论时的地址',
  `os` varchar(64) DEFAULT NULL COMMENT '评论时的系统类型',
  `os_short_name` varchar(20) DEFAULT NULL COMMENT '评论时的系统的简称',
  `browser` varchar(64) DEFAULT NULL COMMENT '评论时的浏览器类型',
  `browser_short_name` varchar(20) DEFAULT NULL COMMENT '评论时的浏览器的简称',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='评论表';

-- ----------------------------
-- Records of biz_comment
-- ----------------------------

-- ----------------------------
-- Table structure for `biz_tags`
-- ----------------------------
DROP TABLE IF EXISTS `biz_tags`;
CREATE TABLE `biz_tags` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `color` varchar(10) DEFAULT '#3385FF' COMMENT '背景',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 COMMENT='标签表';

-- ----------------------------
-- Records of biz_tags
-- ----------------------------
INSERT INTO `biz_tags` VALUES ('1', 'Java', '#ee1db6', 'Java相关标签', 'admin', '2020-02-17 06:48:31', 'admin', '2020-02-17 07:39:51');
INSERT INTO `biz_tags` VALUES ('2', 'Spring Boot', '#f11111', 'Spring Boot 很火的一款框架', 'admin', '2020-02-17 07:27:51', 'admin', '2020-02-17 07:27:51');
INSERT INTO `biz_tags` VALUES ('3', '叼毛', '#29ea0b', '叼嗨', 'admin', '2020-02-17 07:42:03', 'admin', '2020-02-17 07:42:03');
INSERT INTO `biz_tags` VALUES ('7', 'Scalc', '#46A358', 'Scalc', 'admin', '2020-02-22 19:16:37', 'admin', '2020-02-22 19:16:37');
INSERT INTO `biz_tags` VALUES ('8', '爪哇', '#bfe30e', '爪哇', 'admin', '2020-02-22 20:33:39', 'admin', '2020-02-22 20:49:28');
INSERT INTO `biz_tags` VALUES ('9', '叼嗨', '#AE17D1', '叼嗨', 'admin', '2020-02-22 20:33:39', 'admin', '2020-02-22 20:33:39');
INSERT INTO `biz_tags` VALUES ('10', '哇哇', '#A985A7', '哇哇', 'admin', '2020-02-22 20:35:10', 'admin', '2020-02-22 20:35:10');
INSERT INTO `biz_tags` VALUES ('11', 'JavaScript', '#44C987', 'JavaScript', 'admin', '2020-02-24 14:33:24', 'admin', '2020-02-24 14:33:24');
INSERT INTO `biz_tags` VALUES ('12', '测试', '#399E92', '测试', 'admin', '2020-02-25 17:11:26', 'admin', '2020-02-25 17:11:26');
INSERT INTO `biz_tags` VALUES ('13', '封面', '#BE9471', '封面', 'admin', '2020-02-25 17:11:26', 'admin', '2020-02-25 17:11:26');
INSERT INTO `biz_tags` VALUES ('14', '写作', '#BEA822', '写作', 'admin', '2020-02-25 22:06:30', 'admin', '2020-02-25 22:06:30');
INSERT INTO `biz_tags` VALUES ('15', '语法', '#F32D05', '语法', 'admin', '2020-02-25 22:06:30', 'admin', '2020-02-25 22:06:30');
INSERT INTO `biz_tags` VALUES ('16', 'Markdown', '#5898B4', 'Markdown', 'admin', '2020-02-25 22:06:30', 'admin', '2020-02-25 22:06:30');
INSERT INTO `biz_tags` VALUES ('18', '设计模式', '#E44F17', '设计模式', 'admin', '2020-03-28 21:52:35', 'admin', '2020-03-28 21:52:35');
INSERT INTO `biz_tags` VALUES ('19', '编辑器', '#B0A4C4', '编辑器', 'admin', '2020-04-19 21:18:56', 'admin', '2020-04-19 21:18:56');
INSERT INTO `biz_tags` VALUES ('20', 'idea', '#C24703', 'idea', 'admin', '2020-04-19 21:18:56', 'admin', '2020-04-19 21:18:56');
INSERT INTO `biz_tags` VALUES ('21', '礼薄', '#F0438C', '礼薄', 'admin', '2020-04-20 22:34:31', 'admin', '2020-04-20 22:34:31');
INSERT INTO `biz_tags` VALUES ('22', 'MySql', '#869EE9', 'MySql', 'admin', '2020-04-20 22:34:31', 'admin', '2020-04-20 22:34:31');
INSERT INTO `biz_tags` VALUES ('23', '正则', '#09DEAB', '正则', 'admin', '2020-05-13 00:00:11', 'admin', '2020-05-13 00:00:11');
INSERT INTO `biz_tags` VALUES ('24', 'Python', '#4E8816', 'Python', 'admin', '2020-05-25 21:42:02', 'admin', '2020-05-25 21:42:02');

-- ----------------------------
-- Table structure for `sys_config`
-- ----------------------------
DROP TABLE IF EXISTS `sys_config`;
CREATE TABLE `sys_config` (
  `config_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `config_key` varchar(50) NOT NULL COMMENT '配置关键字',
  `config_value` text COMMENT '配置项内容',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`config_id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8 COMMENT='系统配置表';

-- ----------------------------
-- Records of sys_config
-- ----------------------------
INSERT INTO `sys_config` VALUES ('6', 'metaKeywords', 'Blog,博客', null, 'admin', '2020-04-19 17:20:07', 'admin', '2020-04-19 20:58:11');
INSERT INTO `sys_config` VALUES ('7', 'metaDesc', 'CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。', null, 'admin', '2020-04-19 17:20:07', 'admin', '2020-04-19 20:58:11');
INSERT INTO `sys_config` VALUES ('8', 'siteName', '半神半圣亦半仙', null, 'admin', '2020-04-19 17:46:00', 'admin', '2020-04-19 21:04:27');
INSERT INTO `sys_config` VALUES ('9', 'domain', 'http://127.0.0.1', null, 'admin', '2020-04-19 17:46:00', 'admin', '2020-04-19 21:04:27');
INSERT INTO `sys_config` VALUES ('10', 'logo', '/static/images/logo.jpg', null, 'admin', '2020-04-19 17:46:00', 'admin', '2020-04-19 21:04:28');
INSERT INTO `sys_config` VALUES ('11', 'favicon', '/static/images/favicon.ico', null, 'admin', '2020-04-19 17:46:00', 'admin', '2020-04-19 21:04:28');
INSERT INTO `sys_config` VALUES ('12', 'copyright', '© 2020 <a href=\"http://blog.icss.top \">icss.top </a>', null, 'admin', '2020-04-19 17:47:52', 'admin', '2020-05-25 23:14:18');
INSERT INTO `sys_config` VALUES ('13', 'icp', '蜀ICP备19019840号-1', null, 'admin', '2020-04-19 17:47:52', 'admin', '2020-05-25 23:14:18');
INSERT INTO `sys_config` VALUES ('14', 'commentSwitch', '1', null, 'admin', '2020-04-19 17:47:55', 'admin', '2020-04-19 18:01:12');
INSERT INTO `sys_config` VALUES ('15', 'title', '王半仙博客', null, 'admin', '2020-04-19 18:22:05', 'admin', '2020-04-19 20:58:11');
INSERT INTO `sys_config` VALUES ('16', 'statistics', '', null, 'admin', '2020-05-25 22:25:16', 'admin', '2020-05-25 23:14:18');

-- ----------------------------
-- Table structure for `sys_log`
-- ----------------------------
DROP TABLE IF EXISTS `sys_log`;
CREATE TABLE `sys_log` (
  `log_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) DEFAULT NULL COMMENT '用户名',
  `operation` varchar(50) DEFAULT NULL COMMENT '用户操作',
  `method` varchar(200) DEFAULT NULL COMMENT '请求方法',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint(20) DEFAULT NULL COMMENT '执行时长(毫秒)',
  `ip` varchar(64) DEFAULT NULL COMMENT 'IP地址',
  `addr` varchar(100) DEFAULT NULL COMMENT '地址',
  `status` tinyint(1) DEFAULT '0' COMMENT '操作状态（0正常 1异常）',
  `request_url` varchar(255) DEFAULT NULL COMMENT '请求URL',
  `request_method` varchar(10) DEFAULT NULL COMMENT '请求方式',
  `json_result` text COMMENT '响应数据',
  `error_msg` text COMMENT '错误消息',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `create_by` varchar(64) DEFAULT NULL COMMENT '创建者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `update_by` varchar(64) DEFAULT NULL COMMENT '更新者',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB AUTO_INCREMENT=147 DEFAULT CHARSET=utf8 COMMENT='系统日志';

-- ----------------------------
-- Records of sys_log
-- ----------------------------
INSERT INTO `sys_log` VALUES ('4', 'admin', '删除日志', 'com.icss.cnblog.controller.SysLogController.delete()', '[1,3]', '26', '127.0.0.1', '内网IP', '0', '/sys/log/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 13:21:08', 'admin', '2020-02-25 13:21:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('5', 'admin', '删除日志', 'com.icss.cnblog.controller.SysLogController.delete()', '[2]', '9', '127.0.0.1', '内网IP', '0', '/sys/log/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 13:21:36', 'admin', '2020-02-25 13:21:36', 'admin', null);
INSERT INTO `sys_log` VALUES ('6', 'admin', '修改用户信息', 'com.icss.cnblog.controller.SysUserController.updateDetailed()', '{\"avatar\":\"/profile/avatar/2020/02/25/1479441662476013476.jpg\",\"email\":\"ry@163.comm\",\"nickName\":\"超级管理员\",\"phonenumber\":\"15888888881\",\"remark\":\"超级管理员\",\"sex\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1582620162263,\"userId\":1,\"userName\":\"admin\"}', '9', '127.0.0.1', '内网IP', '0', '/sys/user/detailed/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 16:42:42', 'admin', '2020-02-25 16:42:42', 'admin', null);
INSERT INTO `sys_log` VALUES ('7', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', '{\"categoryId\":8,\"comment\":1,\"content\":\"<p>123123</p>\\n\",\"contentMd\":\"123123\",\"coverImage\":\"/profile/upload/2020/02/25/1479441662457006487.jpg\",\"md\":1,\"original\":1,\"password\":\"\",\"recommended\":1,\"status\":0,\"summary\":\"3123\",\"tags\":[\"叼嗨\",\"测试\",\"Spring Boot\",\"哇哇\",\"封面\"],\"title\":\"lala\",\"top\":1,\"userId\":1}', '0', '127.0.0.1', '内网IP', '1', '/sys/article/add', 'POST', 'null', '标签数据最大为3个', '2020-02-25 17:11:11', 'admin', '2020-02-25 17:11:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('8', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', '{\"categoryId\":8,\"comment\":1,\"content\":\"<p>123123</p>\\n\",\"contentMd\":\"123123\",\"coverImage\":\"/profile/upload/2020/02/25/1479441662457006487.jpg\",\"createBy\":\"admin\",\"createTime\":1582621886127,\"id\":7,\"md\":1,\"original\":1,\"password\":\"\",\"recommended\":1,\"status\":0,\"summary\":\"3123\",\"tags\":[\"叼嗨\",\"测试\",\"封面\"],\"title\":\"lala\",\"top\":1,\"updateBy\":\"admin\",\"updateTime\":1582621886127,\"userId\":1}', '78', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 17:11:26', 'admin', '2020-02-25 17:11:26', 'admin', null);
INSERT INTO `sys_log` VALUES ('9', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', '{\"categoryId\":4,\"comment\":1,\"content\":\"<p>11</p>\\n<p><img src=\\\"/profile/upload/2020/02/25/1479441662457006487.jpg\\\" alt=\\\"描述\\\"></p>\\n<p><img src=\\\"/profile/upload/2020/02/25/8bfb2278-9ca5-4224-a415-d5b1c6231a0e.jpg\\\" alt=\\\"描述\\\"></p>\\n\",\"contentMd\":\"11\\n\\n![描述](/profile/upload/2020/02/25/1479441662457006487.jpg)\\n\\n\\n![描述](/profile/upload/2020/02/25/8bfb2278-9ca5-4224-a415-d5b1c6231a0e.jpg)\",\"coverImage\":\"/profile/upload/2020/02/25/1479441788629021891.jpg\",\"id\":5,\"md\":1,\"original\":1,\"password\":\"\",\"recommended\":1,\"status\":0,\"summary\":\"\",\"tags\":[\"叼嗨\",\"哇哇\"],\"title\":\"啦啦啦\",\"top\":1,\"updateBy\":\"admin\",\"updateTime\":1582631872327,\"userId\":1}', '66', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 19:57:52', 'admin', '2020-02-25 19:57:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('11', 'admin', '删除文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.delete()', '[5]', '21', '127.0.0.1', '内网IP', '0', '/sys/article/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 22:17:51', 'admin', '2020-02-25 22:17:51', 'admin', null);
INSERT INTO `sys_log` VALUES ('12', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '66', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 22:18:29', 'admin', '2020-02-25 22:18:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('13', 'admin', '删除文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.delete()', '[7]', '17', '127.0.0.1', '内网IP', '0', '/sys/article/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 22:18:34', 'admin', '2020-02-25 22:18:34', 'admin', null);
INSERT INTO `sys_log` VALUES ('14', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '60', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-25 22:20:26', 'admin', '2020-02-25 22:20:26', 'admin', null);
INSERT INTO `sys_log` VALUES ('15', 'admin', '添加菜单', 'com.icss.cnblog.controller.SysMenuController.add()', '{\"createBy\":\"admin\",\"createTime\":1582786269541,\"icon\":\"\",\"isFrame\":1,\"menuId\":1075,\"menuName\":\"Druid监控\",\"menuType\":\"C\",\"orderNum\":0,\"parentId\":2,\"parentName\":\"系统监控\",\"perms\":\"\",\"remark\":\"监控Sql\",\"updateBy\":\"admin\",\"updateTime\":1582786269541,\"url\":\"/druid/sql.html\",\"visible\":\"0\"}', '17', '127.0.0.1', '内网IP', '0', '/sys/menu/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-02-27 14:51:10', 'admin', '2020-02-27 14:51:10', 'admin', null);
INSERT INTO `sys_log` VALUES ('16', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '98', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/03/21/1479441662476013476.jpg\",\"msg\":\"操作成功\"}', null, '2020-03-21 15:40:59', 'admin', '2020-03-21 15:40:59', 'admin', null);
INSERT INTO `sys_log` VALUES ('17', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '0', '127.0.0.1', '内网IP', '1', '/sys/article/update', 'POST', 'null', '标签数据最大为3个', '2020-03-21 15:41:41', 'admin', '2020-03-21 15:41:41', 'admin', null);
INSERT INTO `sys_log` VALUES ('18', 'admin', '添加类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.add()', '{\"alias\":\"tag\",\"color\":\"#9f13c2\",\"createBy\":\"admin\",\"createTime\":1584782048105,\"id\":9,\"name\":\"三级tag\",\"nav\":0,\"parentId\":4,\"remark\":\"三级\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1584782048105}', '36', '127.0.0.1', '内网IP', '0', '/sys/category/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-21 17:14:08', 'admin', '2020-03-21 17:14:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('19', 'admin', '删除用户', 'com.icss.cnblog.controller.SysUserController.delete()', '[1]', '6', '127.0.0.1', '内网IP', '0', '/sys/user/delete', 'POST', '{\"code\":500,\"msg\":\"超级用户不能删除\"}', null, '2020-03-28 21:21:21', 'admin', '2020-03-28 21:21:21', 'admin', null);
INSERT INTO `sys_log` VALUES ('20', 'admin', '添加用户', 'com.icss.cnblog.controller.SysUserController.add()', '{\"email\":\"ry@163.comm\",\"nickName\":\"dasda\",\"password\":\"11111\",\"phonenumber\":\"15888888881\",\"remark\":\"zz\",\"roleIdList\":[7],\"sex\":\"0\",\"status\":\"0\",\"userName\":\"guest\"}', '0', '127.0.0.1', '内网IP', '1', '/sys/user/add', 'POST', 'null', '用户名已存在！', '2020-03-28 21:43:09', 'admin', '2020-03-28 21:43:09', 'admin', null);
INSERT INTO `sys_log` VALUES ('21', 'admin', '添加用户', 'com.icss.cnblog.controller.SysUserController.add()', '{\"createBy\":\"admin\",\"createTime\":1585402995022,\"email\":\"ry@163.comm\",\"nickName\":\"dasda\",\"password\":\"fc9796855e556ccde170e51c3ac25cae\",\"phonenumber\":\"15888888881\",\"remark\":\"zz\",\"roleIdList\":[7],\"sex\":\"0\",\"status\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1585402995022,\"userId\":5,\"userName\":\"guest1\"}', '40', '127.0.0.1', '内网IP', '0', '/sys/user/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:43:15', 'admin', '2020-03-28 21:43:15', 'admin', null);
INSERT INTO `sys_log` VALUES ('22', 'admin', '修改用户', 'com.icss.cnblog.controller.SysUserController.update()', '{\"email\":\"ry@163.comm\",\"nickName\":\"dasda\",\"password\":\"8ae4de9612c6771de0fdcab15d77566d\",\"phonenumber\":\"15888888881\",\"remark\":\"zz\",\"roleIdList\":[2,7],\"sex\":\"0\",\"status\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1585403008972,\"userId\":5,\"userName\":\"guest1\"}', '27', '127.0.0.1', '内网IP', '0', '/sys/user/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:43:29', 'admin', '2020-03-28 21:43:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('23', 'admin', '删除用户', 'com.icss.cnblog.controller.SysUserController.delete()', '[5]', '15', '127.0.0.1', '内网IP', '0', '/sys/user/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:43:40', 'admin', '2020-03-28 21:43:40', 'admin', null);
INSERT INTO `sys_log` VALUES ('24', 'admin', '添加角色', 'com.icss.cnblog.controller.SysRoleController.add()', '{\"createBy\":\"admin\",\"createTime\":1585403047567,\"menuIdList\":[1061,1062],\"remark\":\"sa\",\"roleId\":8,\"roleKey\":\"lalla\",\"roleName\":\"测试角色\",\"roleSort\":4,\"status\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1585403047568}', '33', '127.0.0.1', '内网IP', '0', '/sys/role/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:44:08', 'admin', '2020-03-28 21:44:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('25', 'admin', '修改角色', 'com.icss.cnblog.controller.SysRoleController.update()', '{\"menuIdList\":[1061,1062,1,1070,1072,100,1001,1002,1003,1004,1007,2,1075],\"remark\":\"sa\",\"roleId\":8,\"roleKey\":\"lalla\",\"roleName\":\"测试角色\",\"roleSort\":4,\"status\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1585403069212}', '69', '127.0.0.1', '内网IP', '0', '/sys/role/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:44:29', 'admin', '2020-03-28 21:44:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('26', 'admin', '删除角色', 'com.icss.cnblog.controller.SysRoleController.delete()', '[8]', '12', '127.0.0.1', '内网IP', '0', '/sys/role/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:44:43', 'admin', '2020-03-28 21:44:43', 'admin', null);
INSERT INTO `sys_log` VALUES ('27', 'admin', '添加菜单', 'com.icss.cnblog.controller.SysMenuController.add()', '{\"createBy\":\"admin\",\"createTime\":1585403127535,\"icon\":\"ww\",\"isFrame\":1,\"menuId\":1076,\"menuName\":\"weqw\",\"menuType\":\"C\",\"orderNum\":0,\"parentId\":1061,\"parentName\":\"百度\",\"perms\":\"asa\",\"remark\":\"qw\",\"updateBy\":\"admin\",\"updateTime\":1585403127535,\"url\":\"qweqweq\",\"visible\":\"0\"}', '19', '127.0.0.1', '内网IP', '0', '/sys/menu/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:45:28', 'admin', '2020-03-28 21:45:28', 'admin', null);
INSERT INTO `sys_log` VALUES ('28', 'admin', '修改菜单', 'com.icss.cnblog.controller.SysMenuController.update()', '{\"icon\":\"ww\",\"isFrame\":1,\"menuId\":1076,\"menuName\":\"weqw\",\"menuType\":\"C\",\"parentId\":0,\"parentName\":\"顶级菜单\",\"perms\":\"asa\",\"remark\":\"qweqweqw\",\"updateBy\":\"admin\",\"updateTime\":1585403166345,\"url\":\"qweqweqeqew\",\"visible\":\"0\"}', '13', '127.0.0.1', '内网IP', '0', '/sys/menu/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:46:06', 'admin', '2020-03-28 21:46:06', 'admin', null);
INSERT INTO `sys_log` VALUES ('29', 'admin', '删除菜单', 'com.icss.cnblog.controller.SysMenuController.delete()', '1076', '23', '127.0.0.1', '内网IP', '0', '/sys/menu/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:46:16', 'admin', '2020-03-28 21:46:16', 'admin', null);
INSERT INTO `sys_log` VALUES ('30', 'admin', '删除日志', 'com.icss.cnblog.controller.SysLogController.delete()', '[10]', '20', '127.0.0.1', '内网IP', '0', '/sys/log/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:46:37', 'admin', '2020-03-28 21:46:37', 'admin', null);
INSERT INTO `sys_log` VALUES ('31', 'admin', '添加配置', 'com.icss.cnblog.controller.SysConfigController.add()', '{\"configId\":4,\"configKey\":\"set\",\"configValue\":\"value\",\"createBy\":\"admin\",\"createTime\":1585403288697,\"remark\":\"zz\",\"updateBy\":\"admin\",\"updateTime\":1585403288697}', '11', '127.0.0.1', '内网IP', '0', '/sys/config/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:48:09', 'admin', '2020-03-28 21:48:09', 'admin', null);
INSERT INTO `sys_log` VALUES ('32', 'admin', '修改配置', 'com.icss.cnblog.controller.SysConfigController.update()', '{\"configId\":4,\"configKey\":\"set\",\"configValue\":\"数据\",\"remark\":\"啦啦啦\",\"updateBy\":\"admin\",\"updateTime\":1585403306208}', '10', '127.0.0.1', '内网IP', '0', '/sys/config/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:48:26', 'admin', '2020-03-28 21:48:26', 'admin', null);
INSERT INTO `sys_log` VALUES ('33', 'admin', '删除配置', 'com.icss.cnblog.controller.SysConfigController.delete()', '[4]', '6', '127.0.0.1', '内网IP', '0', '/sys/config/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:48:32', 'admin', '2020-03-28 21:48:32', 'admin', null);
INSERT INTO `sys_log` VALUES ('34', 'admin', '添加类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.add()', '{\"alias\":\"llala\",\"color\":\"\",\"createBy\":\"admin\",\"createTime\":1585403351858,\"id\":10,\"name\":\"测试\",\"nav\":1,\"parentId\":0,\"remark\":\"dasd\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1585403351858}', '11', '127.0.0.1', '内网IP', '0', '/sys/category/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:49:12', 'admin', '2020-03-28 21:49:12', 'admin', null);
INSERT INTO `sys_log` VALUES ('35', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"llalaeqwe\",\"color\":\"\",\"id\":10,\"name\":\"测试eq\",\"nav\":1,\"parentId\":1,\"remark\":\"dasdweqqwe\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1585403383386}', '11', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:49:43', 'admin', '2020-03-28 21:49:43', 'admin', null);
INSERT INTO `sys_log` VALUES ('36', 'admin', '删除类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.delete()', '10', '6', '127.0.0.1', '内网IP', '0', '/sys/category/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:49:53', 'admin', '2020-03-28 21:49:53', 'admin', null);
INSERT INTO `sys_log` VALUES ('37', 'admin', '添加标签', 'com.icss.cnblog.modules.blog.controller.sys.SysBizTagsController.add()', '{\"color\":\"\",\"createBy\":\"admin\",\"createTime\":1585403405236,\"id\":17,\"name\":\"eqwe\",\"remark\":\"eqw\",\"updateBy\":\"admin\",\"updateTime\":1585403405236}', '13', '127.0.0.1', '内网IP', '0', '/sys/tag/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:50:05', 'admin', '2020-03-28 21:50:05', 'admin', null);
INSERT INTO `sys_log` VALUES ('38', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '72', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 21:52:35', 'admin', '2020-03-28 21:52:35', 'admin', null);
INSERT INTO `sys_log` VALUES ('39', 'admin', '修改标签', 'com.icss.cnblog.modules.blog.controller.sys.SysBizTagsController.update()', '{\"color\":\"#e41919\",\"id\":17,\"name\":\"eqwe\",\"remark\":\"eqw\",\"updateBy\":\"admin\",\"updateTime\":1585404139838}', '21', '127.0.0.1', '内网IP', '0', '/sys/tag/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 22:02:20', 'admin', '2020-03-28 22:02:20', 'admin', null);
INSERT INTO `sys_log` VALUES ('40', 'admin', '删除标签', 'com.icss.cnblog.modules.blog.controller.sys.SysBizTagsController.delete()', '[17]', '28', '127.0.0.1', '内网IP', '0', '/sys/tag/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 22:02:30', 'admin', '2020-03-28 22:02:30', 'admin', null);
INSERT INTO `sys_log` VALUES ('41', 'admin', '修改用户信息', 'com.icss.cnblog.controller.SysUserController.updateDetailed()', '{\"avatar\":\"/profile/avatar/2020/02/25/1479441662476013476.jpg\",\"email\":\"root@163.comm\",\"nickName\":\"超级管理员\",\"phonenumber\":\"15888888881\",\"remark\":\"超级管理员\",\"sex\":\"0\",\"updateBy\":\"admin\",\"updateTime\":1585404229113,\"userId\":1,\"userName\":\"admin\"}', '9', '127.0.0.1', '内网IP', '0', '/sys/user/detailed/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-28 22:03:49', 'admin', '2020-03-28 22:03:49', 'admin', null);
INSERT INTO `sys_log` VALUES ('42', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '124', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-03-29 13:50:35', 'admin', '2020-03-29 13:50:35', 'admin', null);
INSERT INTO `sys_log` VALUES ('43', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"java\",\"color\":\"#18e834\",\"id\":3,\"name\":\"JAVA\",\"nav\":1,\"parentId\":1,\"remark\":\"\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788481456}', '24', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:34:42', 'admin', '2020-04-13 22:34:42', 'admin', null);
INSERT INTO `sys_log` VALUES ('44', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"html\",\"color\":\"\",\"id\":4,\"name\":\"HTML\",\"nav\":1,\"parentId\":1,\"remark\":\"\",\"sort\":1,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788507484}', '8', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:35:07', 'admin', '2020-04-13 22:35:07', 'admin', null);
INSERT INTO `sys_log` VALUES ('45', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"tag\",\"color\":\"#9f13c2\",\"id\":9,\"name\":\"三级tag\",\"nav\":1,\"parentId\":4,\"remark\":\"三级\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788538716}', '9', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:35:39', 'admin', '2020-04-13 22:35:39', 'admin', null);
INSERT INTO `sys_log` VALUES ('46', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"test\",\"color\":\"#e146f2\",\"id\":8,\"name\":\"测试很长的\",\"nav\":1,\"parentId\":0,\"remark\":\"\",\"sort\":2,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788838895}', '8', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:40:39', 'admin', '2020-04-13 22:40:39', 'admin', null);
INSERT INTO `sys_log` VALUES ('47', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"gg\",\"color\":\"\",\"id\":6,\"name\":\"游戏\",\"nav\":1,\"parentId\":2,\"remark\":\"\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788852061}', '10', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:40:52', 'admin', '2020-04-13 22:40:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('48', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"leisure\",\"color\":\"\",\"id\":2,\"name\":\"闲情\",\"nav\":0,\"parentId\":0,\"remark\":\"\",\"sort\":1,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1586788870595}', '9', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-13 22:41:11', 'admin', '2020-04-13 22:41:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('49', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '72', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-18 00:25:22', 'admin', '2020-04-18 00:25:22', 'admin', null);
INSERT INTO `sys_log` VALUES ('50', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '24', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-18 00:25:58', 'admin', '2020-04-18 00:25:58', 'admin', null);
INSERT INTO `sys_log` VALUES ('51', 'admin', '添加菜单', 'com.icss.cnblog.controller.SysMenuController.add()', '{\"createBy\":\"admin\",\"createTime\":1587270148482,\"icon\":\"\",\"isFrame\":1,\"menuId\":1077,\"menuName\":\"系统设置\",\"menuType\":\"C\",\"orderNum\":5,\"parentId\":1,\"parentName\":\"系统管理\",\"perms\":\"\",\"remark\":\"系统配置\",\"updateBy\":\"admin\",\"updateTime\":1587270148482,\"url\":\"/sys/config/system.html\",\"visible\":\"0\"}', '23', '127.0.0.1', '内网IP', '0', '/sys/menu/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 12:22:29', 'admin', '2020-04-19 12:22:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('52', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '16', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 16:59:41', 'admin', '2020-04-19 16:59:41', 'admin', null);
INSERT INTO `sys_log` VALUES ('53', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '4', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:05:39', 'admin', '2020-04-19 17:05:39', 'admin', null);
INSERT INTO `sys_log` VALUES ('54', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '9', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:07:14', 'admin', '2020-04-19 17:07:14', 'admin', null);
INSERT INTO `sys_log` VALUES ('55', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '10', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:09:14', 'admin', '2020-04-19 17:09:14', 'admin', null);
INSERT INTO `sys_log` VALUES ('56', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '11777', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:09:40', 'admin', '2020-04-19 17:09:40', 'admin', null);
INSERT INTO `sys_log` VALUES ('57', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '10', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:11:30', 'admin', '2020-04-19 17:11:30', 'admin', null);
INSERT INTO `sys_log` VALUES ('58', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '4', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:12:18', 'admin', '2020-04-19 17:12:18', 'admin', null);
INSERT INTO `sys_log` VALUES ('59', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '8878', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:12:51', 'admin', '2020-04-19 17:12:51', 'admin', null);
INSERT INTO `sys_log` VALUES ('60', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '10', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:14:10', 'admin', '2020-04-19 17:14:10', 'admin', null);
INSERT INTO `sys_log` VALUES ('61', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{}', '13', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:16:04', 'admin', '2020-04-19 17:16:04', 'admin', null);
INSERT INTO `sys_log` VALUES ('62', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"半仙\",\"metaKeywords\":\"\",\"metaDesc\":\"\"}', '79', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:20:07', 'admin', '2020-04-19 17:20:07', 'admin', null);
INSERT INTO `sys_log` VALUES ('63', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"半仙\",\"metaKeywords\":\"Blog,博客\",\"metaDesc\":\"CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。\"}', '84', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:44:34', 'admin', '2020-04-19 17:44:34', 'admin', null);
INSERT INTO `sys_log` VALUES ('64', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"半仙-博客\",\"metaKeywords\":\"Blog,博客\",\"metaDesc\":\"CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。\"}', '59', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:45:34', 'admin', '2020-04-19 17:45:34', 'admin', null);
INSERT INTO `sys_log` VALUES ('65', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"siteName\":\"半仙\",\"domain\":\"http://127.0.0.1\",\"logo\":\"logo\",\"favicon\":\"ico\"}', '53', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:46:00', 'admin', '2020-04-19 17:46:00', 'admin', null);
INSERT INTO `sys_log` VALUES ('66', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2018 icss.top MIT license\",\"icp\":\"浙ICP备17008806号-3\"}', '38', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:47:52', 'admin', '2020-04-19 17:47:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('67', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"commentSwitch\":\"1\"}', '16', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 17:47:55', 'admin', '2020-04-19 17:47:55', 'admin', null);
INSERT INTO `sys_log` VALUES ('68', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"commentSwitch\":\"1\"}', '60', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:01:12', 'admin', '2020-04-19 18:01:12', 'admin', null);
INSERT INTO `sys_log` VALUES ('69', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 icss.top MIT license\",\"icp\":\"浙ICP备17008806号-3\"}', '62', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:04:22', 'admin', '2020-04-19 18:04:22', 'admin', null);
INSERT INTO `sys_log` VALUES ('70', 'admin', '删除配置', 'com.icss.cnblog.controller.SysConfigController.delete()', '[1]', '40', '127.0.0.1', '内网IP', '0', '/sys/config/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:21:19', 'admin', '2020-04-19 18:21:19', 'admin', null);
INSERT INTO `sys_log` VALUES ('71', 'admin', '删除配置', 'com.icss.cnblog.controller.SysConfigController.delete()', '[3]', '20', '127.0.0.1', '内网IP', '0', '/sys/config/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:21:23', 'admin', '2020-04-19 18:21:23', 'admin', null);
INSERT INTO `sys_log` VALUES ('72', 'admin', '删除配置', 'com.icss.cnblog.controller.SysConfigController.delete()', '[5]', '276', '127.0.0.1', '内网IP', '0', '/sys/config/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:21:29', 'admin', '2020-04-19 18:21:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('73', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"首页\",\"metaKeywords\":\"Blog,博客\",\"metaDesc\":\"CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。\"}', '56', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 18:22:05', 'admin', '2020-04-19 18:22:05', 'admin', null);
INSERT INTO `sys_log` VALUES ('74', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"王半仙博客\",\"metaKeywords\":\"Blog,博客\",\"metaDesc\":\"CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。\"}', '69', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 20:57:51', 'admin', '2020-04-19 20:57:51', 'admin', null);
INSERT INTO `sys_log` VALUES ('75', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"siteName\":\"半神半圣亦半仙\",\"domain\":\"http://127.0.0.1\",\"logo\":\"\",\"favicon\":\"\"}', '60', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 20:58:05', 'admin', '2020-04-19 20:58:05', 'admin', null);
INSERT INTO `sys_log` VALUES ('76', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"title\":\"王半仙博客\",\"metaKeywords\":\"Blog,博客\",\"metaDesc\":\"CnBlog是一款简洁美观、自适应的Java博客系统。使用springboot开发，前端使用Bootstrap。支持移动端自适应，配有完备的前台和后台管理功能。\"}', '42', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 20:58:11', 'admin', '2020-04-19 20:58:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('77', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"siteName\":\"半神半圣亦半仙\",\"domain\":\"http://127.0.0.1\",\"logo\":\"/static/images/logo.jpg\",\"favicon\":\"/static/images/favicon.ico\"}', '102', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 21:04:28', 'admin', '2020-04-19 21:04:28', 'admin', null);
INSERT INTO `sys_log` VALUES ('78', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '130', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 21:18:56', 'admin', '2020-04-19 21:18:56', 'admin', null);
INSERT INTO `sys_log` VALUES ('79', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '105', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-19 21:39:21', 'admin', '2020-04-19 21:39:21', 'admin', null);
INSERT INTO `sys_log` VALUES ('80', 'admin', '添加菜单', 'com.icss.cnblog.controller.SysMenuController.add()', '{\"createBy\":\"admin\",\"createTime\":1587392650929,\"icon\":\"\",\"isFrame\":1,\"menuId\":1078,\"menuName\":\"网站管理\",\"menuType\":\"M\",\"orderNum\":3,\"parentId\":0,\"parentName\":\"顶级菜单\",\"perms\":\"\",\"remark\":\"网站管理\",\"updateBy\":\"admin\",\"updateTime\":1587392650929,\"url\":\"\",\"visible\":\"0\"}', '15', '127.0.0.1', '内网IP', '0', '/sys/menu/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:24:11', 'admin', '2020-04-20 22:24:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('81', 'admin', '修改菜单', 'com.icss.cnblog.controller.SysMenuController.update()', '{\"icon\":\"\",\"isFrame\":1,\"menuId\":1077,\"menuName\":\"网站设置\",\"menuType\":\"C\",\"orderNum\":0,\"parentId\":1078,\"parentName\":\"网站管理\",\"perms\":\"\",\"remark\":\"网站设置\",\"updateBy\":\"admin\",\"updateTime\":1587392695604,\"url\":\"/sys/config/system.html\",\"visible\":\"0\"}', '18', '127.0.0.1', '内网IP', '0', '/sys/menu/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:24:56', 'admin', '2020-04-20 22:24:56', 'admin', null);
INSERT INTO `sys_log` VALUES ('82', 'admin', '修改菜单', 'com.icss.cnblog.controller.SysMenuController.update()', '{\"icon\":\"layui-icon-website\",\"isFrame\":1,\"menuId\":1078,\"menuName\":\"网站管理\",\"menuType\":\"M\",\"orderNum\":3,\"parentId\":0,\"parentName\":\"顶级菜单\",\"perms\":\"\",\"remark\":\"网站管理\",\"updateBy\":\"admin\",\"updateTime\":1587392780010,\"url\":\"\",\"visible\":\"0\"}', '9', '127.0.0.1', '内网IP', '0', '/sys/menu/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:26:20', 'admin', '2020-04-20 22:26:20', 'admin', null);
INSERT INTO `sys_log` VALUES ('83', 'admin', '修改菜单', 'com.icss.cnblog.controller.SysMenuController.update()', '{\"icon\":\"\",\"isFrame\":1,\"menuId\":1077,\"menuName\":\"网站配置\",\"menuType\":\"C\",\"orderNum\":0,\"parentId\":1078,\"parentName\":\"网站管理\",\"perms\":\"\",\"remark\":\"网站配置\",\"updateBy\":\"admin\",\"updateTime\":1587392860880,\"url\":\"/sys/config/system.html\",\"visible\":\"0\"}', '10', '127.0.0.1', '内网IP', '0', '/sys/menu/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:27:41', 'admin', '2020-04-20 22:27:41', 'admin', null);
INSERT INTO `sys_log` VALUES ('84', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '102', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:34:31', 'admin', '2020-04-20 22:34:31', 'admin', null);
INSERT INTO `sys_log` VALUES ('85', 'admin', '添加类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.add()', '{\"alias\":\"mysql\",\"color\":\"#dd00ff\",\"createBy\":\"admin\",\"createTime\":1587393434476,\"id\":11,\"name\":\"MySql\",\"nav\":1,\"parentId\":0,\"remark\":\"MySql\",\"sort\":0,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1587393434476}', '10', '127.0.0.1', '内网IP', '0', '/sys/category/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:37:14', 'admin', '2020-04-20 22:37:14', 'admin', null);
INSERT INTO `sys_log` VALUES ('86', 'admin', '修改类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.update()', '{\"alias\":\"test\",\"color\":\"#e146f2\",\"id\":8,\"name\":\"测试很长的\",\"nav\":1,\"parentId\":0,\"remark\":\"\",\"sort\":2,\"status\":0,\"updateBy\":\"admin\",\"updateTime\":1587393450904}', '14', '127.0.0.1', '内网IP', '0', '/sys/category/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-20 22:37:31', 'admin', '2020-04-20 22:37:31', 'admin', null);
INSERT INTO `sys_log` VALUES ('87', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '64', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-21 21:42:53', 'admin', '2020-04-21 21:42:53', 'admin', null);
INSERT INTO `sys_log` VALUES ('88', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '82', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-22 23:01:48', 'admin', '2020-04-22 23:01:48', 'admin', null);
INSERT INTO `sys_log` VALUES ('89', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '20', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-22 23:02:20', 'admin', '2020-04-22 23:02:20', 'admin', null);
INSERT INTO `sys_log` VALUES ('90', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '101', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/04/22/0.jpg\",\"msg\":\"操作成功\"}', null, '2020-04-22 23:03:14', 'admin', '2020-04-22 23:03:14', 'admin', null);
INSERT INTO `sys_log` VALUES ('91', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '18', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-22 23:03:21', 'admin', '2020-04-22 23:03:21', 'admin', null);
INSERT INTO `sys_log` VALUES ('92', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '111', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-04-27 21:24:11', 'admin', '2020-04-27 21:24:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('93', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '67', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-13 00:00:11', 'admin', '2020-05-13 00:00:11', 'admin', null);
INSERT INTO `sys_log` VALUES ('94', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '47', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-13 00:02:21', 'admin', '2020-05-13 00:02:21', 'admin', null);
INSERT INTO `sys_log` VALUES ('95', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '81', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 21:42:03', 'admin', '2020-05-25 21:42:03', 'admin', null);
INSERT INTO `sys_log` VALUES ('96', 'admin', '添加类别', 'com.icss.cnblog.modules.blog.controller.sys.SysBizCategoryController.add()', '{\"alias\":\"python\",\"color\":\"#dd10f4\",\"createBy\":\"admin\",\"createTime\":1590414188450,\"id\":12,\"name\":\"Python\",\"nav\":1,\"parentId\":1,\"remark\":\"python \",\"sort\":3,\"status\":1,\"updateBy\":\"admin\",\"updateTime\":1590414188450}', '18', '127.0.0.1', '内网IP', '0', '/sys/category/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 21:43:08', 'admin', '2020-05-25 21:43:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('97', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '18', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 21:44:02', 'admin', '2020-05-25 21:44:02', 'admin', null);
INSERT INTO `sys_log` VALUES ('98', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 icss.top MIT license\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '35', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 22:25:16', 'admin', '2020-05-25 22:25:16', 'admin', null);
INSERT INTO `sys_log` VALUES ('99', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 icss.top \",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '48', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 22:30:23', 'admin', '2020-05-25 22:30:23', 'admin', null);
INSERT INTO `sys_log` VALUES ('100', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 <a href=\\\"icss.top \\\">icss.top </a>\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '38', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 22:33:27', 'admin', '2020-05-25 22:33:27', 'admin', null);
INSERT INTO `sys_log` VALUES ('101', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 <a href=\\\"icss.top \\\">icss.top </a>\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '46', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 22:34:09', 'admin', '2020-05-25 22:34:09', 'admin', null);
INSERT INTO `sys_log` VALUES ('102', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 <a href=\\\"/icss.top \\\">icss.top </a>\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '34', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 23:12:57', 'admin', '2020-05-25 23:12:57', 'admin', null);
INSERT INTO `sys_log` VALUES ('103', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 <a href=\\\"http://icss.top \\\">icss.top </a>\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '34', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 23:13:36', 'admin', '2020-05-25 23:13:36', 'admin', null);
INSERT INTO `sys_log` VALUES ('104', 'admin', '网站配置', 'com.icss.cnblog.controller.SysConfigController.website()', '{\"copyright\":\"© 2020 <a href=\\\"http://blog.icss.top \\\">icss.top </a>\",\"icp\":\"蜀ICP备19019840号-1\",\"statistics\":\"\"}', '24', '127.0.0.1', '内网IP', '0', '/sys/config/website', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-05-25 23:14:18', 'admin', '2020-05-25 23:14:18', 'admin', null);
INSERT INTO `sys_log` VALUES ('105', 'admin', '删除用户', 'com.icss.cnblog.controller.SysUserController.delete()', '[1]', '4', '127.0.0.1', '内网IP', '0', '/sys/user/delete', 'POST', '{\"code\":500,\"msg\":\"超级用户不能删除\"}', null, '2020-06-27 16:36:06', 'admin', '2020-06-27 16:36:06', 'admin', null);
INSERT INTO `sys_log` VALUES ('106', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '93', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/06/29/00.jpg\",\"msg\":\"操作成功\"}', null, '2020-06-29 23:23:56', 'admin', '2020-06-29 23:23:56', 'admin', null);
INSERT INTO `sys_log` VALUES ('107', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '59', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-06-29 23:24:19', 'admin', '2020-06-29 23:24:19', 'admin', null);
INSERT INTO `sys_log` VALUES ('108', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '95', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-06-29 23:37:16', 'admin', '2020-06-29 23:37:16', 'admin', null);
INSERT INTO `sys_log` VALUES ('109', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '40', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-06-29 23:44:08', 'admin', '2020-06-29 23:44:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('110', 'admin', '删除文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.delete()', '[16]', '20', '127.0.0.1', '内网IP', '0', '/sys/article/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-06-29 23:44:19', 'admin', '2020-06-29 23:44:19', 'admin', null);
INSERT INTO `sys_log` VALUES ('111', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '20', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-06-29 23:44:53', 'admin', '2020-06-29 23:44:53', 'admin', null);
INSERT INTO `sys_log` VALUES ('112', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '64', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"width\":440,\"error\":1,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593613618639.jpg\",\"height\":440}', null, '2020-07-01 22:26:59', 'admin', '2020-07-01 22:26:59', 'admin', null);
INSERT INTO `sys_log` VALUES ('113', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '77', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614174191.jpg\",\"width\":89,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614174191.jpg\",\"height\":79}', null, '2020-07-01 22:36:15', 'admin', '2020-07-01 22:36:15', 'admin', null);
INSERT INTO `sys_log` VALUES ('114', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '12', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614211750.png\",\"width\":806,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614211750.png\",\"height\":389}', null, '2020-07-01 22:36:52', 'admin', '2020-07-01 22:36:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('115', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '25', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614262455.jpg\",\"width\":1680,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614262455.jpg\",\"height\":1050}', null, '2020-07-01 22:37:43', 'admin', '2020-07-01 22:37:43', 'admin', null);
INSERT INTO `sys_log` VALUES ('116', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '106', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:37:52', 'admin', '2020-07-01 22:37:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('117', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '15', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614301833.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614301833.jpg\",\"height\":200}', null, '2020-07-01 22:38:22', 'admin', '2020-07-01 22:38:22', 'admin', null);
INSERT INTO `sys_log` VALUES ('118', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '20', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614324400.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614324400.jpg\",\"height\":200}', null, '2020-07-01 22:38:45', 'admin', '2020-07-01 22:38:45', 'admin', null);
INSERT INTO `sys_log` VALUES ('119', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '8', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/07/01/00.jpg\",\"msg\":\"操作成功\"}', null, '2020-07-01 22:39:01', 'admin', '2020-07-01 22:39:01', 'admin', null);
INSERT INTO `sys_log` VALUES ('120', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '62', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:39:08', 'admin', '2020-07-01 22:39:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('121', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '29', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:40:29', 'admin', '2020-07-01 22:40:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('122', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '11', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:40:38', 'admin', '2020-07-01 22:40:38', 'admin', null);
INSERT INTO `sys_log` VALUES ('123', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '33', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593614501746.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593614501746.jpg\",\"height\":200}', null, '2020-07-01 22:41:42', 'admin', '2020-07-01 22:41:42', 'admin', null);
INSERT INTO `sys_log` VALUES ('124', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '11', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:41:47', 'admin', '2020-07-01 22:41:47', 'admin', null);
INSERT INTO `sys_log` VALUES ('125', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '13', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 22:44:30', 'admin', '2020-07-01 22:44:30', 'admin', null);
INSERT INTO `sys_log` VALUES ('126', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '84', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615192458.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615192458.jpg\",\"height\":200}', null, '2020-07-01 22:53:13', 'admin', '2020-07-01 22:53:13', 'admin', null);
INSERT INTO `sys_log` VALUES ('127', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '12', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615241337.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615241337.jpg\",\"height\":200}', null, '2020-07-01 22:54:01', 'admin', '2020-07-01 22:54:01', 'admin', null);
INSERT INTO `sys_log` VALUES ('128', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '40', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615275668.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615275668.jpg\",\"height\":200}', null, '2020-07-01 22:54:36', 'admin', '2020-07-01 22:54:36', 'admin', null);
INSERT INTO `sys_log` VALUES ('129', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '24', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615306858.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615306858.jpg\",\"height\":200}', null, '2020-07-01 22:55:07', 'admin', '2020-07-01 22:55:07', 'admin', null);
INSERT INTO `sys_log` VALUES ('130', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '12', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615313202.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615313202.jpg\",\"height\":200}', null, '2020-07-01 22:55:13', 'admin', '2020-07-01 22:55:13', 'admin', null);
INSERT INTO `sys_log` VALUES ('131', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '27', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615320764.jpg\",\"width\":180,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615320764.jpg\",\"height\":180}', null, '2020-07-01 22:55:21', 'admin', '2020-07-01 22:55:21', 'admin', null);
INSERT INTO `sys_log` VALUES ('132', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '7', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/07/01/10.jpg\",\"msg\":\"操作成功\"}', null, '2020-07-01 23:02:40', 'admin', '2020-07-01 23:02:40', 'admin', null);
INSERT INTO `sys_log` VALUES ('133', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '58', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 23:03:01', 'admin', '2020-07-01 23:03:01', 'admin', null);
INSERT INTO `sys_log` VALUES ('134', 'admin', '删除文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.delete()', '[18]', '20', '127.0.0.1', '内网IP', '0', '/sys/article/delete', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 23:03:09', 'admin', '2020-07-01 23:03:09', 'admin', null);
INSERT INTO `sys_log` VALUES ('135', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '10', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593615999127.png\",\"width\":1127,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593615999127.png\",\"height\":576}', null, '2020-07-01 23:06:39', 'admin', '2020-07-01 23:06:39', 'admin', null);
INSERT INTO `sys_log` VALUES ('136', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '13', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/01/1593616025325.png\",\"width\":984,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/01/1593616025325.png\",\"height\":557}', null, '2020-07-01 23:07:05', 'admin', '2020-07-01 23:07:05', 'admin', null);
INSERT INTO `sys_log` VALUES ('137', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '21', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-01 23:07:31', 'admin', '2020-07-01 23:07:31', 'admin', null);
INSERT INTO `sys_log` VALUES ('138', 'admin', '上传头像', 'com.icss.cnblog.controller.SysUserController.uploadAvatar()', null, '39', '127.0.0.1', '内网IP', '0', '/sys/user/uploadAvatar', 'POST', '{\"code\":200,\"data\":\"/profile/avatar/2020/07/01/3.jpg\",\"msg\":\"操作成功\"}', null, '2020-07-01 23:10:13', 'admin', '2020-07-01 23:10:13', 'admin', null);
INSERT INTO `sys_log` VALUES ('139', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '116', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/04/1593851451673.jpg\",\"width\":200,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/04/1593851451673.jpg\",\"height\":200}', null, '2020-07-04 16:30:52', 'admin', '2020-07-04 16:30:52', 'admin', null);
INSERT INTO `sys_log` VALUES ('140', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '29', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"error\":1,\"message\":\"不支持的图片类型\"}', null, '2020-07-04 16:31:00', 'admin', '2020-07-04 16:31:00', 'admin', null);
INSERT INTO `sys_log` VALUES ('141', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '50', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/04/1593851489222.jpg\",\"width\":586,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/04/1593851489222.jpg\",\"height\":352}', null, '2020-07-04 16:31:29', 'admin', '2020-07-04 16:31:29', 'admin', null);
INSERT INTO `sys_log` VALUES ('142', 'admin', '上传文章Markdown编辑器图片', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.uploadAvatar()', null, '0', '127.0.0.1', '内网IP', '0', '/sys/article/upload/markdown', 'POST', '{\"isImage\":true,\"filename\":\"2020/07/04/1593851534424.png\",\"width\":322,\"error\":0,\"message\":\"上传成功\",\"url\":\"/profile/upload/2020/07/04/1593851534424.png\",\"height\":322}', null, '2020-07-04 16:32:14', 'admin', '2020-07-04 16:32:14', 'admin', null);
INSERT INTO `sys_log` VALUES ('143', 'admin', '上传文章封面', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.upload()', null, '6', '127.0.0.1', '内网IP', '0', '/sys/article/upload', 'POST', '{\"code\":200,\"data\":\"/profile/upload/2020/07/04/00.jpg\",\"msg\":\"操作成功\"}', null, '2020-07-04 16:33:56', 'admin', '2020-07-04 16:33:56', 'admin', null);
INSERT INTO `sys_log` VALUES ('144', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '66', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-04 16:34:08', 'admin', '2020-07-04 16:34:08', 'admin', null);
INSERT INTO `sys_log` VALUES ('145', 'admin', '修改文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.update()', null, '67', '127.0.0.1', '内网IP', '0', '/sys/article/update', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-07-05 15:07:32', 'admin', '2020-07-05 15:07:32', 'admin', null);
INSERT INTO `sys_log` VALUES ('146', 'admin', '添加文章', 'com.icss.cnblog.modules.blog.controller.sys.SysBizArticleController.add()', null, '116', '127.0.0.1', '内网IP', '0', '/sys/article/add', 'POST', '{\"code\":200,\"msg\":\"操作成功\"}', null, '2020-09-02 21:52:15', 'admin', '2020-09-02 21:52:15', 'admin', null);

-- ----------------------------
-- Table structure for `sys_menu`
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu` (
  `menu_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) NOT NULL COMMENT '菜单名称',
  `parent_id` bigint(20) DEFAULT '0' COMMENT '父菜单ID',
  `order_num` int(4) DEFAULT '0' COMMENT '显示顺序',
  `url` varchar(255) DEFAULT NULL COMMENT '路由地址',
  `is_frame` int(1) DEFAULT '1' COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `perms` varchar(100) DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标',
  `create_by` varchar(64) DEFAULT '' COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) DEFAULT '' COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT '' COMMENT '备注',
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1079 DEFAULT CHARSET=utf8mb4 COMMENT='菜单权限表';

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES ('1', '系统管理', '0', '1', '', '1', 'M', '0', '', 'layui-icon-set-fill', 'admin', '2018-03-16 11:33:00', null, null, '系统管理目录');
INSERT INTO `sys_menu` VALUES ('2', '系统监控', '0', '2', '', '1', 'M', '0', '', 'layui-icon-engine', 'admin', '2018-03-16 11:33:00', null, null, '系统监控目录');
INSERT INTO `sys_menu` VALUES ('100', '用户管理', '1', '1', '/sys/user/list.html', '1', 'C', '0', 'sys:user:list', 'user', 'admin', '2018-03-16 11:33:00', null, null, '用户管理菜单');
INSERT INTO `sys_menu` VALUES ('101', '角色管理', '1', '2', '/sys/role/list.html', '1', 'C', '0', 'sys:role:list', 'peoples', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '角色管理菜单');
INSERT INTO `sys_menu` VALUES ('102', '菜单管理', '1', '3', '/sys/menu/list.html', '1', 'C', '0', 'sys:menu:list', 'tree-table', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '菜单管理菜单');
INSERT INTO `sys_menu` VALUES ('109', '在线用户', '2', '1', '/sys/online/list.html', '1', 'C', '0', 'sys:online:list', 'online', 'admin', '2018-03-16 11:33:00', null, null, '在线用户菜单');
INSERT INTO `sys_menu` VALUES ('1001', '用户查询', '100', '1', '', '1', 'F', '0', 'sys:user:query,sys:user:info', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1002', '用户新增', '100', '2', '', '1', 'F', '0', 'sys:user:add', '#', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '');
INSERT INTO `sys_menu` VALUES ('1003', '用户修改', '100', '3', '', '1', 'F', '0', 'sys:user:update,sys:role:select', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1004', '用户删除', '100', '4', '', '1', 'F', '0', 'sys:user:delete', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1007', '重置密码', '100', '7', '', '1', 'F', '0', 'syst:user:resetPwd', '#', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '');
INSERT INTO `sys_menu` VALUES ('1008', '角色查询', '101', '1', '', '1', 'F', '0', 'sys:role:info,sys:menu:tree', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1009', '角色新增', '101', '2', '', '1', 'F', '0', 'syst:role:add', '#', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '');
INSERT INTO `sys_menu` VALUES ('1010', '角色修改', '101', '3', '', '1', 'F', '0', 'sys:role:update', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1011', '角色删除', '101', '4', '', '1', 'F', '0', 'sys:role:delete', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1013', '菜单查询', '102', '1', '', '1', 'F', '0', 'sys:menu:info,sys:menu:select', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1014', '菜单新增', '102', '2', '', '1', 'F', '0', 'sys:menu:add', '#', 'admin', '2018-03-16 11:33:00', 'ry', '2018-03-16 11:33:00', '');
INSERT INTO `sys_menu` VALUES ('1015', '菜单修改', '102', '3', '', '1', 'F', '0', 'sys:menu:update', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1016', '菜单删除', '102', '4', '', '1', 'F', '0', 'sys:menu:delete', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1048', '单条强退', '109', '3', '', '1', 'F', '0', 'sys:online:kickout', '#', 'admin', '2018-03-16 11:33:00', null, null, '');
INSERT INTO `sys_menu` VALUES ('1061', '百度', '0', '0', 'http://www.baidu.com', '1', 'C', '0', '', 'layui-icon-release', 'admin', '2020-02-11 13:14:04', 'admin', '2020-02-11 13:14:04', '');
INSERT INTO `sys_menu` VALUES ('1062', '基本资料', '0', '0', '', '1', 'C', '1', '', '', 'admin', '2020-02-11 13:58:41', null, null, '');
INSERT INTO `sys_menu` VALUES ('1063', '左侧导航', '102', '0', '', '1', 'F', '0', 'sys:menu:nav', '', 'admin', '2020-02-12 05:32:22', 'admin', '2020-02-12 05:32:22', '系统后台左侧菜单导航');
INSERT INTO `sys_menu` VALUES ('1064', '文章管理', '0', '0', '', '1', 'M', '0', '', 'layui-icon-tabs', 'admin', '2020-02-16 10:10:39', 'admin', '2020-02-16 10:10:39', '');
INSERT INTO `sys_menu` VALUES ('1065', '分类管理', '1064', '0', '/sys/category/list.html', '1', 'C', '0', 'sys:category:list', '', 'admin', '2020-02-16 10:12:58', 'admin', '2020-02-16 10:12:58', '');
INSERT INTO `sys_menu` VALUES ('1066', '标签管理', '1064', '0', '/sys/tag/list.html', '1', 'C', '0', 'sys:tag:list', '', 'admin', '2020-02-17 06:47:49', 'admin', '2020-02-17 06:47:49', '');
INSERT INTO `sys_menu` VALUES ('1067', '文章管理', '1064', '1', '/sys/article/list.html', '1', 'C', '0', 'sys:article:list', '', 'admin', '2020-02-18 15:07:44', 'admin', '2020-02-18 15:07:44', '');
INSERT INTO `sys_menu` VALUES ('1068', '发布文章', '1064', '0', '/sys/article/add.html', '1', 'C', '0', '', '', 'admin', '2020-02-18 15:09:10', 'admin', '2020-02-18 15:09:10', '');
INSERT INTO `sys_menu` VALUES ('1069', '日志管理', '1', '0', '/sys/log/list.html', '1', 'C', '0', 'sys:log:list', '', 'admin', '2020-02-25 12:15:36', 'admin', '2020-02-25 12:15:36', '');
INSERT INTO `sys_menu` VALUES ('1070', '配置管理', '1', '0', '/sys/config/list.html', '1', 'C', '0', 'sys:config:list', '', 'admin', '2020-02-25 12:16:32', 'admin', '2020-02-25 12:16:32', '');
INSERT INTO `sys_menu` VALUES ('1071', '配置新增', '1070', '1', '', '1', 'F', '0', 'sys:config:add', '', 'admin', '2020-02-25 12:17:45', 'admin', '2020-02-25 12:20:34', '');
INSERT INTO `sys_menu` VALUES ('1072', '修改配置', '1070', '2', '', '1', 'F', '0', 'sys:config:update', '', 'admin', '2020-02-25 12:18:50', 'admin', '2020-02-25 12:18:50', '');
INSERT INTO `sys_menu` VALUES ('1073', '配置查询', '1070', '0', '', '1', 'F', '0', 'sys:config:info', '', 'admin', '2020-02-25 12:19:46', 'admin', '2020-02-25 12:19:46', '');
INSERT INTO `sys_menu` VALUES ('1074', '配置删除', '1070', '3', '', '1', 'F', '0', 'sys:config:delete', '', 'admin', '2020-02-25 12:20:18', 'admin', '2020-02-25 12:20:18', '');
INSERT INTO `sys_menu` VALUES ('1075', 'Druid监控', '2', '0', '/druid/sql.html', '1', 'C', '0', '', '', 'admin', '2020-02-27 14:51:10', 'admin', '2020-02-27 14:51:10', '监控Sql');
INSERT INTO `sys_menu` VALUES ('1077', '网站配置', '1078', '0', '/sys/config/system.html', '1', 'C', '0', '', '', 'admin', '2020-04-19 12:22:28', 'admin', '2020-04-20 22:27:41', '网站配置');
INSERT INTO `sys_menu` VALUES ('1078', '网站管理', '0', '3', '', '1', 'M', '0', '', 'layui-icon-website', 'admin', '2020-04-20 22:24:11', 'admin', '2020-04-20 22:26:20', '网站管理');

-- ----------------------------
-- Table structure for `sys_role`
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `role_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) NOT NULL COMMENT '角色权限字符串',
  `role_sort` int(4) NOT NULL COMMENT '显示顺序',
  `status` char(1) NOT NULL COMMENT '角色状态（0正常 1停用）',
  `create_by` varchar(64) DEFAULT '' COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) DEFAULT '' COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COMMENT='角色信息表';

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES ('1', '管理员', 'admin', '1', '0', 'admin', '2018-03-16 11:33:00', null, null, '管理员');
INSERT INTO `sys_role` VALUES ('2', '普通角色', 'common', '2', '0', 'admin', '2018-03-16 11:33:00', null, null, '普通角色');
INSERT INTO `sys_role` VALUES ('7', '游客', 'guest', '3', '0', 'admin', '2020-02-11 13:21:01', null, null, '游客');

-- ----------------------------
-- Table structure for `sys_role_menu`
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu` (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`,`menu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色和菜单关联表';

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES ('1', '1');
INSERT INTO `sys_role_menu` VALUES ('1', '2');
INSERT INTO `sys_role_menu` VALUES ('1', '100');
INSERT INTO `sys_role_menu` VALUES ('1', '101');
INSERT INTO `sys_role_menu` VALUES ('1', '102');
INSERT INTO `sys_role_menu` VALUES ('1', '109');
INSERT INTO `sys_role_menu` VALUES ('1', '1001');
INSERT INTO `sys_role_menu` VALUES ('1', '1002');
INSERT INTO `sys_role_menu` VALUES ('1', '1003');
INSERT INTO `sys_role_menu` VALUES ('1', '1004');
INSERT INTO `sys_role_menu` VALUES ('1', '1007');
INSERT INTO `sys_role_menu` VALUES ('1', '1008');
INSERT INTO `sys_role_menu` VALUES ('1', '1009');
INSERT INTO `sys_role_menu` VALUES ('1', '1010');
INSERT INTO `sys_role_menu` VALUES ('1', '1011');
INSERT INTO `sys_role_menu` VALUES ('1', '1013');
INSERT INTO `sys_role_menu` VALUES ('1', '1014');
INSERT INTO `sys_role_menu` VALUES ('1', '1015');
INSERT INTO `sys_role_menu` VALUES ('1', '1016');
INSERT INTO `sys_role_menu` VALUES ('1', '1048');
INSERT INTO `sys_role_menu` VALUES ('1', '1061');
INSERT INTO `sys_role_menu` VALUES ('1', '1062');
INSERT INTO `sys_role_menu` VALUES ('1', '1063');
INSERT INTO `sys_role_menu` VALUES ('2', '1');
INSERT INTO `sys_role_menu` VALUES ('2', '2');
INSERT INTO `sys_role_menu` VALUES ('2', '100');
INSERT INTO `sys_role_menu` VALUES ('2', '101');
INSERT INTO `sys_role_menu` VALUES ('2', '102');
INSERT INTO `sys_role_menu` VALUES ('2', '109');
INSERT INTO `sys_role_menu` VALUES ('2', '1001');
INSERT INTO `sys_role_menu` VALUES ('2', '1002');
INSERT INTO `sys_role_menu` VALUES ('2', '1003');
INSERT INTO `sys_role_menu` VALUES ('2', '1007');
INSERT INTO `sys_role_menu` VALUES ('2', '1008');
INSERT INTO `sys_role_menu` VALUES ('2', '1009');
INSERT INTO `sys_role_menu` VALUES ('2', '1010');
INSERT INTO `sys_role_menu` VALUES ('2', '1013');
INSERT INTO `sys_role_menu` VALUES ('2', '1014');
INSERT INTO `sys_role_menu` VALUES ('2', '1015');
INSERT INTO `sys_role_menu` VALUES ('2', '1048');
INSERT INTO `sys_role_menu` VALUES ('2', '1061');
INSERT INTO `sys_role_menu` VALUES ('2', '1063');
INSERT INTO `sys_role_menu` VALUES ('7', '1');
INSERT INTO `sys_role_menu` VALUES ('7', '2');
INSERT INTO `sys_role_menu` VALUES ('7', '100');
INSERT INTO `sys_role_menu` VALUES ('7', '101');
INSERT INTO `sys_role_menu` VALUES ('7', '102');
INSERT INTO `sys_role_menu` VALUES ('7', '109');
INSERT INTO `sys_role_menu` VALUES ('7', '1001');
INSERT INTO `sys_role_menu` VALUES ('7', '1008');
INSERT INTO `sys_role_menu` VALUES ('7', '1013');
INSERT INTO `sys_role_menu` VALUES ('7', '1015');
INSERT INTO `sys_role_menu` VALUES ('7', '1048');
INSERT INTO `sys_role_menu` VALUES ('7', '1061');
INSERT INTO `sys_role_menu` VALUES ('7', '1063');

-- ----------------------------
-- Table structure for `sys_user`
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `user_name` varchar(30) NOT NULL COMMENT '用户账号',
  `nick_name` varchar(30) NOT NULL COMMENT '用户昵称',
  `user_type` varchar(2) DEFAULT '00' COMMENT '用户类型（00系统用户）',
  `email` varchar(50) DEFAULT '' COMMENT '用户邮箱',
  `phonenumber` varchar(11) DEFAULT '' COMMENT '手机号码',
  `sex` char(1) DEFAULT '0' COMMENT '用户性别（0男 1女 2未知）',
  `avatar` varchar(100) DEFAULT '' COMMENT '头像地址',
  `password` varchar(100) DEFAULT '' COMMENT '密码',
  `status` char(1) DEFAULT '0' COMMENT '帐号状态（0正常 1停用）',
  `login_ip` varchar(50) DEFAULT '' COMMENT '最后登陆IP',
  `login_date` datetime DEFAULT NULL COMMENT '最后登陆时间',
  `create_by` varchar(64) DEFAULT '' COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` varchar(64) DEFAULT '' COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COMMENT='用户信息表';

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES ('1', 'admin', '超级管理员', '00', 'root@163.comm', '15888888881', '0', '/profile/avatar/2020/07/01/3.jpg', 'a66abb5684c45962d887564f08346e8d', '0', '127.0.0.1', '2020-09-02 21:48:20', 'admin', '2018-03-16 11:33:00', 'admin', '2020-09-02 21:48:20', '超级管理员');
INSERT INTO `sys_user` VALUES ('3', 'banxian', '半仙', '00', '14163548@qq.com', '18512815891', '0', '', '0c1409b4c4355b39b01e88f2a6132941', '0', '127.0.0.1', '2020-02-17 16:41:08', '', '2020-02-09 09:29:56', 'banxian', '2020-02-17 16:41:08', '一人之下，万人之上。');
INSERT INTO `sys_user` VALUES ('4', 'guest', '游客', '00', '111@qq.com', '16512815891', '1', '', '34e20b52f5bd120db806e57e27f47ed0', '0', '', null, 'ry', '2020-02-09 09:39:14', null, null, '游客');

-- ----------------------------
-- Table structure for `sys_user_role`
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role` (
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`,`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户和角色关联表';

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES ('3', '1');
INSERT INTO `sys_user_role` VALUES ('3', '2');
INSERT INTO `sys_user_role` VALUES ('4', '7');
